<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>麦茶小站</title><link>https://chengyuan-artist.github.io/</link><description>Recent content on 麦茶小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>麦茶</copyright><lastBuildDate>Sat, 25 Nov 2023 19:18:12 +0800</lastBuildDate><atom:link href="https://chengyuan-artist.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>《红猪》“因为他们的心，被大海和蓝天洗过”</title><link>https://chengyuan-artist.github.io/posts/movie_porco_rosso/</link><pubDate>Sat, 25 Nov 2023 19:18:12 +0800</pubDate><guid>https://chengyuan-artist.github.io/posts/movie_porco_rosso/</guid><description>&lt;img src="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126000336734.png" alt="Featured image of post 《红猪》“因为他们的心，被大海和蓝天洗过” " />&lt;p>上周五看的电影，晚上写的影评，硬生生拖到现在才发（&lt;/p>
&lt;p>&lt;img src="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126003139913.png"
width="2560"
height="1453"
srcset="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126003139913_hu1286235875363148396.png 480w, https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126003139913_hu2086364350301383369.png 1024w"
loading="lazy"
alt="世上没有比飞艇飞行员更叫人喜欢了，因为他们的心，被大海和蓝天洗过"
class="gallery-image"
data-flex-grow="176"
data-flex-basis="422px"
>&lt;/p>
&lt;h2 id="印象深刻的场景">印象深刻的场景&lt;/h2>
&lt;p>极致的浪漫！大海，天空，白云，飞艇。&lt;/p>
&lt;p>&lt;img src="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126000336734.png"
width="2560"
height="1384"
srcset="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126000336734_hu15461446831647490908.png 480w, https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126000336734_hu8414822814904055274.png 1024w"
loading="lazy"
alt="水花，白云中翻腾的红色飞艇"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="443px"
>&lt;/p>
&lt;p>&lt;img src="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125235148965.png"
width="2560"
height="1388"
srcset="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125235148965_hu3432565635127361093.png 480w, https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125235148965_hu3150426409061472933.png 1024w"
loading="lazy"
alt="外表为猪却依然帅气的主人公"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/p>
&lt;p>&lt;img src="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125232652330.png"
width="2560"
height="1394"
srcset="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125232652330_hu12246575933509520375.png 480w, https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125232652330_hu9676922891901095098.png 1024w"
loading="lazy"
alt="机械尺，图纸。经由人类设计的复杂装置的美感"
class="gallery-image"
data-flex-grow="183"
data-flex-basis="440px"
>&lt;/p>
&lt;p>&lt;img src="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125235314116.png"
width="2560"
height="1389"
srcset="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125235314116_hu4648919761254501380.png 480w, https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125235314116_hu1409361824560422291.png 1024w"
loading="lazy"
alt="复杂机械咆哮的美感"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/p>
&lt;p>&lt;img src="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126000220833.png"
width="2560"
height="1391"
srcset="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126000220833_hu3412824725831426246.png 480w, https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126000220833_hu605749142094604225.png 1024w"
loading="lazy"
alt="重生的红色飞艇在城市水道起航"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="441px"
>&lt;/p>
&lt;p>&lt;img src="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125232955395.png"
width="2560"
height="1390"
srcset="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125232955395_hu9592254885946616553.png 480w, https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125232955395_hu5253944007800618672.png 1024w"
loading="lazy"
alt="在白天私人花园中等待的吉娜小姐"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="442px"
>&lt;/p>
&lt;p>&lt;img src="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125234728168.png"
width="2560"
height="1391"
srcset="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125234728168_hu4546180107426784717.png 480w, https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125234728168_hu8436432078699033418.png 1024w"
loading="lazy"
alt="牺牲战士的飞机汇成长河"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="441px"
>&lt;/p>
&lt;h2 id="为什么是猪">为什么是猪？&lt;/h2>
&lt;p>&lt;img src="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126002924153.png"
width="2560"
height="1440"
srcset="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126002924153_hu4911909664459687784.png 480w, https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126002924153_hu10300096944855006613.png 1024w"
loading="lazy"
alt="不能飞的猪，只是猪而已|正是飞行赋予了红猪自由的特质"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;p>主人公为什么会变成猪。猪是懒惰，散漫又毫无责任感的象征。主人公正是被时代/政府视作懒散不负责任，因为在那个经济低迷，战火和冲突纷发的年代，个人唯有将其全部价值奉献给民族和国家，才是时代/政府眼中负责任的做法，主人公作为原空军本领高强的飞行高手，却不为国家出力，而是隐居荒岛靠赏金为生，&lt;strong>因此才被时代/政府定义成猪&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126003249690.png"
width="2560"
height="1439"
srcset="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126003249690_hu9578801619548889598.png 480w, https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126003249690_hu3378229307213546786.png 1024w"
loading="lazy"
alt="会飞的猪也依然是猪|不为国家效力，你就是懒惰的猪|背景里猪作为反派被打飞"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;p>但懒惰，散漫和毫无责任感这些词语的背后，正是宝贵的&lt;strong>自由&lt;/strong>。自由地在大海和蓝天之中遨游，自由地追求和捍卫飞行员的荣耀，不受国家和法律的约束，不必与他人自相残杀，不必眼睁睁而又无可奈何地看着昔日的战友死去。需要牵挂的，只有一位老朋友，做自由的游侠，也并不耽误每晚酒会与老友的会面。可以说，&lt;strong>主人公是自愿变成“猪”的&lt;/strong>。&lt;/p>
&lt;p>但自由有其代价，红猪所选择的自由之路是终究不会被时代和政府承认的。卖汽油店里的老人对主人公说靠他的能力加入组织中一定能赚大钱；军队中的旧识也希望主人公能重归部队，至少在部队中有人脉可以保护他。但红猪知道自己要走什么路，也知道自己的路如何凶险和艰难。这也是为何他坚决不让机械师小姐跟随自己踏上自己的道路；对心上人吉娜也始终以敬爱的朋友之情相对，尽管从宿敌卡吉士口中了解到吉娜对自己的心意，在这个无法给予心上人幸福保证的时代，主人公也无法轻易地迈出这一步。&lt;/p>
&lt;p>幸运的是，当时代悄然改变，能够宽容自由之日，那主人公也就不会再是猪的形态。结尾红色的机翼，吉娜并不在白天的私人花园，似乎暗示着红猪不同以往的结局。&lt;strong>祝福他们，并向浪漫和自由致敬！&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125233611015.png"
width="2560"
height="1393"
srcset="https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125233611015_hu8993300099937058007.png 480w, https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231125233611015_hu2272049535830845904.png 1024w"
loading="lazy"
alt="右岸有架红色的飞机|结尾吉娜并不在白天的花园"
class="gallery-image"
data-flex-grow="183"
data-flex-basis="441px"
>&lt;/p>
&lt;p>另外，对于来自美国的卡吉士其人，也并非穷凶极恶的反派，反而也是同样追求着自由，荣耀，爱情，甚至带些天真和傻气。吉娜之言“你没有经历过我们所经历的”。没有沉重的包袱，反而能飞的更高更远，最终与红猪也几乎不分胜负。但没有经历与成长，无法成为真正的男人，也是为何他被吉娜拒绝：“请你自己去好莱坞吧，小男孩”，也是为什么红猪能最终走入吉娜心中。&lt;/p></description></item><item><title>算法笔记|二叉堆，二项堆和斐波那契堆（原理篇）</title><link>https://chengyuan-artist.github.io/posts/algo_heap/</link><pubDate>Wed, 15 Nov 2023 20:43:01 +0800</pubDate><guid>https://chengyuan-artist.github.io/posts/algo_heap/</guid><description>&lt;img src="https://chengyuan-artist.github.io/posts/algo_heap/images/image-feature.png" alt="Featured image of post 算法笔记|二叉堆，二项堆和斐波那契堆（原理篇）" />&lt;h2 id="优先队列">优先队列&lt;/h2>
&lt;h3 id="动机">动机&lt;/h3>
&lt;p>某些情况下，我们需要频繁地&lt;strong>动态&lt;/strong>地取出一个集合S中的最小元素/最大元素。&lt;/p>
&lt;p>这里&lt;strong>动态&lt;/strong>指我们需要在集合S上执行插入/删除/更改键值操作。&lt;/p>
&lt;p>问题在于如何组织数据结构使这些操作更高效。&lt;/p>
&lt;h3 id="操作定义">操作定义&lt;/h3>
&lt;p>以最小优先队列为例：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>方法名&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>MakeHeap()&lt;/td>
&lt;td>建立一个堆H&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Insert(H, x)&lt;/td>
&lt;td>在堆H中插入元素x&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ExtractMin(H)&lt;/td>
&lt;td>提取堆H中的最小元素&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DecreaseKey(H, x, k)&lt;/td>
&lt;td>减小堆中元素x的键值为k&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Union(H1 , H2 )&lt;/td>
&lt;td>返回一个新堆包含H1和H2的所有元素，销毁输入堆&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="应用举例">应用举例&lt;/h3>
&lt;ul>
&lt;li>Dijkstra单源最短路算法：需要&lt;code>ExtractMin&lt;/code>&lt;/li>
&lt;li>Prim最小生成树算法：需要&lt;code>ExtractMin&lt;/code>与&lt;code>DecreaseKey&lt;/code>&lt;/li>
&lt;li>Why we need Union?&lt;/li>
&lt;/ul>
&lt;h2 id="数组链表实现">数组/链表实现&lt;/h2>
&lt;p>我们可以用数组或链表快速实现一个简单版本的优先队列。&lt;/p>
&lt;p>由于本篇偏向理论分析，因此更在意数据结构的&lt;strong>逻辑结构&lt;/strong>而非物理结构。对以下两种实现方式而言，可以认为数组的逻辑结构和链表相同（实际上二者复杂度分析也相同），因此都用链表代替。&lt;/p>
&lt;h3 id="无序链表实现">无序链表实现&lt;/h3>
&lt;img src="./images/image-20231115215858165.png" alt="image-20231115215858165" style="zoom: 50%;" />
&lt;p>每次都在首部插入新元素；提取最小值时，遍历链表找到最小值并更改链表指针将其从链表中删除。&lt;/p>
&lt;p>（数组版本）每次在尾部插入新元素；提取最小值时，遍历数组找到最小值并将其与尾部元素交换位置，减小长度计数。&lt;/p>
&lt;p>复杂度：&lt;/p>
&lt;ul>
&lt;li>插入操作：$O(1)$&lt;/li>
&lt;li>提取最小值：$O(n)$&lt;/li>
&lt;/ul>
&lt;h3 id="有序链表实现">有序链表实现&lt;/h3>
&lt;img src="./images/image-20231115220444807.png" alt="image-20231115220444807" style="zoom:50%;" />
&lt;p>插入新元素时，遍历链表至第一个大于其的元素位置处，在此之前插入；提取最小值直接返回首部，并将其删除（更改头指针）。&lt;/p>
&lt;p>（数组版本）倒序维护数组大小，插入新元素时，遍历链表至第一个小于其的元素位置处，在此之前插入，后续元素后移；提取最小值时直接返回尾部，并将其删除（减小长度计数）。&lt;/p>
&lt;p>复杂度：&lt;/p>
&lt;ul>
&lt;li>插入操作：$O(n)$&lt;/li>
&lt;li>提取最小值：$O(1)$&lt;/li>
&lt;/ul>
&lt;h3 id="问题">问题&lt;/h3>
&lt;p>是否存在使得插入和提取最小值时间复杂度更均衡/更优的数据结构？&lt;/p>
&lt;h2 id="二叉堆">二叉堆&lt;/h2>
&lt;p>观察有序链表实现，插入操作实际上每次都在进行插入排序以维持整个链表的有序，然而这属于工作过头了，我们只需要维护一个最小值。&lt;/p>
&lt;ul>
&lt;li>有序链表的每个指针指向的元素都大于等于自身，数据结构限制过于严格，因此需要&lt;strong>放松限制&lt;/strong>。&lt;/li>
&lt;li>但限制不能&lt;strong>过分放松&lt;/strong>，否则就会像无序链表那样，元素间没有任何限制，导致提取操作复杂度上升。&lt;/li>
&lt;/ul>
&lt;p>二叉堆：&lt;/p>
&lt;ul>
&lt;li>逻辑结构：一颗二叉树，且父结点小于子结点。所有结点除最后一层外按照完全二叉树排列。&lt;/li>
&lt;/ul>
&lt;img src="images/image-20231115224930406.png" alt="image-20231115224930406" style="zoom: 67%;" />
&lt;ul>
&lt;li>
&lt;p>物理结构：为了便于随机读取以及减少指针开销。结点以完全二叉树编号为下标放入数组中。&lt;/p>
&lt;img src="images/image-20231115225848350.png" alt="image-20231115225848350" style="zoom: 67%;" />
&lt;p>因此对结点$i$ ，左子结点下标为$2i$，右子结点下标为$2(i + 1)$，父结点下标为$ (i-1)/2$（向下取整）。下标越界时，表示结点不存在。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>操作：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>插入：将新元素置于二叉堆尾部，依次向上调整，使得最小堆性质（父结点小于子结点）保持。由于二叉堆高为$log_2n$（$n$为元素个数），因此时间复杂度为$O(logn)$。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>提取最小值：将堆顶元素与堆尾元素交换，减小堆数组长度计数，从根结点开始依次向下调整，使得最小堆性质保持。时间复杂度为$O(logn)$。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>DecreaseKey(x, k)&lt;/code>：将下标&lt;code>x&lt;/code>处元素值降低为&lt;code>k&lt;/code>。从该元素开始依次向上调整。时间复杂度为$O(logn)$。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>建堆：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>通过建空堆依次入堆。时间复杂度$O(nlogn)$。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过&amp;quot;遍历堆化&amp;quot;实现。将所有元素原封不动地入堆，随后调整堆结构。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>方法：按照完全二叉树编号从尾结点开始向根结点依次调用“向下调整”。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>时间复杂度：将堆补充为完全二叉树，不影响复杂度计算。设层高为$d = log_2n$。从上到下依次为第0&amp;hellip;d层。对第i层，操作总次数为$2^i*(d-i)$​。因此总操作数
$$
T(n)=2^0d+2^1(d-1)+2^2(d-2)&amp;hellip;+2^{d-1}
$$&lt;/p>
&lt;p>$$
2T(n)=2^1d+2^2(d-1)+&amp;hellip;+2^{d}
$$&lt;/p>
&lt;p>故
$$
T(n)=2^1+2^2+&amp;hellip;+2^d -d=2\frac{1-2^d}{1-2}-d=2^{d+1}-d-2=O(2^{d+1})=O(n)
$$&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>合并：将两个堆的数据组成一个堆，再遍历堆化。$O(n)$。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>至此，我们得到了插入，提取，改键均为$O(logn)$，且合并为$O(n)$的堆。实现简单且复杂度不错。&lt;/p>
&lt;h3 id="问题-1">问题&lt;/h3>
&lt;p>如果想进一步降低&lt;strong>合并&lt;/strong>的复杂度，该怎样调整数据结构？&lt;/p>
&lt;h2 id="二项式堆">二项式堆&lt;/h2>
&lt;p>观察二叉堆的逻辑结构，我们发现只允许&lt;strong>一棵树&lt;/strong>存在这一限制。因此在两个堆合并时，需要拆散两颗树合并为一颗。如果允许多棵树存在，逻辑结构不是一棵树而是&lt;strong>森林&lt;/strong>。合并时无需破坏原有堆的结构。&lt;/p>
&lt;ul>
&lt;li>放松限制：一棵树 -&amp;gt; 允许森林&lt;/li>
&lt;li>不要过分放松：&lt;strong>同类型&lt;/strong>的树只存在一颗。&lt;/li>
&lt;/ul>
&lt;p>综上，既然允许多棵树存在，插入操作就变成了&lt;strong>合并&lt;/strong>操作，即合并一颗只含根结点的树，直接将其插入森林中即可；由于同类型的树只能有一颗，我们需要合并&lt;strong>同类型&lt;/strong>的树，合并后的树也应该属于&lt;strong>某个类型&lt;/strong>。&lt;/p>
&lt;h3 id="二项树">二项树&lt;/h3>
&lt;p>定义：$B_k$为二项式树，定义$k$为$B_k$的度数。&lt;/p>
&lt;ul>
&lt;li>$B_0$只含有一个结点&lt;/li>
&lt;li>两个$B_k$可以合并为$B_{k+1}$&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>这里合并操作指将$B_k$作为另一$B_k$的根结点的儿子插入。&lt;/p>
&lt;/blockquote>
&lt;p>这样的定义使二项树有一些有趣的性质：&lt;/p>
&lt;ul>
&lt;li>$B_k$树层高为$k$&lt;/li>
&lt;li>$B_{k}$树的每个子结点分别为$B_0,B_1,&amp;hellip;,B_{k-1}$ （$B_k$树的第$i$个子结点的度为$i-1$）&lt;/li>
&lt;li>$B_k$树的每层结点个数正好是$k$的二项式系数（$(a+b)^k$）（命名来源）&lt;/li>
&lt;li>$|B_k|=2^k$&lt;/li>
&lt;/ul>
&lt;h3 id="二项堆">二项堆&lt;/h3>
&lt;p>定义：二项堆为二项树组成的森林&lt;/p>
&lt;ul>
&lt;li>其中每个度数的二项树只有一颗&lt;/li>
&lt;li>对于二项堆中的每颗二项树，满足最小堆性质&lt;/li>
&lt;/ul>
&lt;p>由此，当二项堆里有相同类型的二项树需要合并时，取根结点最小的树的根结点作为父结点，将另一棵树作为其儿子插入。&lt;/p>
&lt;p>二叉堆二项树根结点用双向链表连接，指针指向最小的根结点。&lt;/p>
&lt;p>二项堆也有一些有趣的性质：&lt;/p>
&lt;ul>
&lt;li>对于规模为$n$的二项堆，其二项树的组合是&lt;strong>确定&lt;/strong>的。二项堆含有$B_i$当且仅当$b_i=1$，其中$(b_kb_{k-1}&amp;hellip;b_0)_2=n$。&lt;/li>
&lt;li>二项堆最多含有$log_2n$（向下取整）颗二项树&lt;/li>
&lt;li>二项堆的层高不超过$log_2n$（向下取整）&lt;/li>
&lt;/ul>
&lt;p>操作：&lt;/p>
&lt;ul>
&lt;li>插入：合并一颗$B_0$树。最好情况下$O(1)$，最坏情况下$O(logn)$，均摊复杂度为$O(1)$。这是什么？别急&lt;/li>
&lt;li>提取最小值：将最小根结点取出，将该二项树拆为其所有子树，合并相同类型的二项树。$O(logn)$。&lt;/li>
&lt;li>合并：复杂度$O(logn)$，均摊复杂度$O(1)$。&lt;/li>
&lt;li>减小键值：在某颗二项树上向上调整。$O(logn)$。&lt;/li>
&lt;/ul>
&lt;h3 id="均摊分析">均摊分析&lt;/h3>
&lt;p>为什么要均摊分析？在分析插入/合并/提取最小值时，我们总考虑工作量的上限，即最坏情况，推出复杂度均为$O(logn)$。但是这三个操作复杂度在时间上具有继承性，如果做了一次工作量较大的操作，随后许多次操作都只需要很小的工作量。这种情况下可以引入&lt;strong>势能分析&lt;/strong>。&lt;/p>
&lt;h4 id="插入">插入&lt;/h4>
&lt;p>伪代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Insert(x) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Creat a B0 tree for x;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Change the pointer to the min root;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (there are two Bk tree for some k) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Link them into one Bk+1 tree;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Change the pointer to the min root;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>一次插入操作需要消耗$1+w$时间，$w=\#while$ 是&lt;code>while&lt;/code>语句执行的数量，$\#$表示&lt;code>number of&lt;/code>。&lt;/p>
&lt;p>引入势函数$\Phi=\#tree$，即二叉堆中树的数量。当进行一次插入操作后，势函数可以分为上升的部分和下降的部分。&lt;/p>
&lt;ul>
&lt;li>上升：$1$&lt;/li>
&lt;li>下降：$w$，即树减少的数量&lt;/li>
&lt;/ul>
&lt;p>因此一次插入操作需要$1+decrease\ in\ \Phi$。而由于$\Phi&amp;gt;=0$，故$all\ decrease\ in\ \Phi &amp;lt;= all\ increase\ in\ \Phi$。这为我们统计一系列操作提供了方便。&lt;/p>
&lt;p>可以看到，当分析合并时，伪代码与插入只有第二行的区别，一次合并操作需要的时间也是$1+decrease\ in\ \Phi$。&lt;/p>
&lt;h4 id="提取最小值">提取最小值&lt;/h4>
&lt;p>伪代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ExtractMin(H) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Remove the min node and insert its children to the root list;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Change the pointer to the min node;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (there are two Bk tree for some k) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Link them into one Bk+1 tree;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Change the pointer to the min root;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>一次操作需要消耗$d+w$，$w=\#while$，$d$为去除根结点的树的度（也是其子树数量）。&lt;/p>
&lt;p>我们用同样的势函数$\Phi=\#tree$。进行一次操作，势函数既有上升的部分也有下降的部分。&lt;/p>
&lt;ul>
&lt;li>上升：$d$&lt;/li>
&lt;li>下降：$w$&lt;/li>
&lt;/ul>
&lt;p>因此一次操作需要$d+decrease\ in\ \Phi$。其中$d&amp;lt;=log_2n$。&lt;/p>
&lt;h4 id="分析">分析&lt;/h4>
&lt;p>若对一个二叉堆做了$a$次插入操作和$b$次提取最小值操作，总消耗的时间&lt;/p>
&lt;p>$$
\begin{align*}
T(a,b)&amp;amp;= a(1+decrease\ in\ \Phi)+b(d+decrease\ in\ \Phi) \\\
&amp;amp;\le a(1+increase\ in\ \Phi)+b(d+increase\ in\ \Phi) \\\
&amp;amp;=a+bd+all\ increase\ in\ \Phi \\\
&amp;amp;=a+bd+a+bd=2a+2bd \\\
&amp;amp;\le 2a+2blogn
\end{align*}
$$
由于$n$与$m$无关，因此插入操作的均摊复杂度为$O(\frac{T(a)}{a})=O(1)$，提取最小值的操作的均摊复杂度为$O(\frac{T(b)}{b})=O(logn)$。合并操作均摊复杂度与插入操作相同，为$O(1)$。&lt;/p>
&lt;h3 id="问题-2">问题&lt;/h3>
&lt;p>对比二叉堆，我们成功地将合并操作的复杂度降低为$O(1)$（均摊）。如果进一步考虑，如何降低&lt;strong>减小键值&lt;/strong>的复杂度呢？&lt;/p>
&lt;h2 id="斐波那契堆">斐波那契堆&lt;/h2>
&lt;p>对于减小键值操作，无论是二叉堆还是二项堆，都避免不了对堆进行调整的操作。为了降低复杂度，能否进行操作后，不进行或推迟调整操作？&lt;/p>
&lt;p>斐波那契堆在二项堆的基础上：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>放松限制&lt;/strong>，允许同类型的二项树共存；同时在减小键值操作后，并不调整堆而是直接将该结点及其子树摘下放入根结点列表中，同时给该结点的父结点打上标记，已表明该父节点“失去”过一个结点。（1）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>注意到该限制不是&lt;strong>完全放松&lt;/strong>的，对每颗二项树而言，非根结点最多失去一个结点。（2）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>“摘下”操作相当于取消了原来的堆调整过程，将其推迟到堆做合并时。减小键值对应着摘下结点。&lt;/p>
&lt;p>当已被标记的结点的子结点被摘下后，该结点应取消标记并也被摘下，递归地向父结点进行直至没有标记。&lt;/p>
&lt;p>根结点不允许失去结点 -&amp;gt; 便于统计树的度数 。&lt;/p>
&lt;/blockquote>
&lt;p>注意到由于条件（1）的存在，插入和合并都只需向根结点列表中添加新的树即可。但堆总要做出调整，何时？&lt;/p>
&lt;p>答案是不得不调整时，即&lt;strong>提取最小值&lt;/strong>后，此时无论如何都要进行合并操作了，否则根结点列表数量将膨胀。&lt;/p>
&lt;p>合并操作是合并&lt;strong>相同度数&lt;/strong>的树。树的度数等于根结点的子结点数目。&lt;/p>
&lt;p>操作：&lt;/p>
&lt;ul>
&lt;li>插入：合并一颗$B_0$树。复杂度$O(1)$。&lt;/li>
&lt;li>提取最小值：将最小根结点取出，将拆为其所有子树并插入根结点列表。最坏&amp;amp;均摊$O(logn)$。为什么？&lt;/li>
&lt;li>合并：复杂度$O(1)$。&lt;/li>
&lt;li>减小键值：均摊复杂度$O(1)$。&lt;/li>
&lt;/ul>
&lt;h3 id="均摊分析-1">均摊分析&lt;/h3>
&lt;h4 id="提取最小值-1">提取最小值&lt;/h4>
&lt;p>伪代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ExtractMin() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Remove the min node and insert its children to the root list;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Change the pointer to the min node;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (there are two roots u and v of the same degree) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Consolidate the two trees together;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Change the pointer to the min root;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>与二叉堆的操作相同，但这里我们使用新的势函数$\Phi=\#tree+2\#mark$，$\#mark$为被标记的非根结点数量。 why?&lt;/p>
&lt;p>一次提取最小值操作带来的势函数变化为：&lt;/p>
&lt;ul>
&lt;li>上升（静态）：$d$（移除结点的度）&lt;/li>
&lt;li>下降（动态）：$w$&lt;/li>
&lt;/ul>
&lt;p>一次操作需要$d+decrease\ in\ \Phi$，$d$为根结点的度。&lt;/p>
&lt;blockquote>
&lt;p>注意到由于树会被摘下结点，因此$d$有可能大于$log_2n$。&lt;/p>
&lt;p>想象单颗二项树的情景，有$d=log_2n$，由于$n$减小，故$d&amp;gt;log_2n$。扩展到堆也可能成立。&lt;/p>
&lt;p>因此均摊操作复杂度取决于$d$的上界，后续会证明$d$的上界。思路：找到二项树对应的结点数最小的树，即斐波那契树的结点数目。&lt;/p>
&lt;/blockquote>
&lt;h4 id="减小键值">减小键值&lt;/h4>
&lt;p>再回想一下减小键值的操作：&lt;/p>
&lt;blockquote>
&lt;p>减小键值对应着摘下结点（若堆序被破坏）。&lt;/p>
&lt;p>当已被标记的结点的子结点被摘下后，该结点应取消标记并也被摘下，递归地向父结点进行直至没有标记。&lt;/p>
&lt;p>根结点不能失去结点：对父结点为根结点的操作特殊处理。&lt;/p>
&lt;/blockquote>
&lt;p>伪代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">DecreaseKey(x, k) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> key(x) = k;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (heap order is violated) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> p = x-&amp;gt;parent;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (p is root node) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Swap key between p and x;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Cut the subtree rooted at x, and insert it into the root list;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Change the pointer to the min root node;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (p is marked) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Cut the subtree rooted at p, and insert it into the root list;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Change the pointer to the min root node;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Unmark p;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> p = p-&amp;gt;parent;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Mark p;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>为了复杂度计算方便，暂时先不考虑&lt;code>x&lt;/code>的父结点为根结点的情况。由伪代码可以得到，一次操作消耗的时间为$1+w,w=\#while$。&lt;/p>
&lt;p>考察势函数$\Phi=\#tree+2\#mark$，一次减小键值操作带来的势函数变化为：&lt;/p>
&lt;ul>
&lt;li>上升（静态）：$1+2=3$&lt;/li>
&lt;li>下降（动态）：$（-1+2）w=w$&lt;/li>
&lt;/ul>
&lt;p>故一次操作消耗的时间为$1+decrease\ in\ \Phi$。&lt;/p>
&lt;p>当&lt;code>x&lt;/code>的父结点为根结点时也符合上式。&lt;/p>
&lt;h4 id="插入-1">插入&lt;/h4>
&lt;p>$\Phi$上升$1$，下降$0$。&lt;/p>
&lt;p>一次操作消耗的时间为$1$。&lt;/p>
&lt;h4 id="分析-1">分析&lt;/h4>
&lt;p>考虑一段操作序列：$r$次插入，$s$次提取最小值，$t$次减小键值。&lt;/p>
&lt;p>总的运行时间最大为：$r+sd_{max}+t+total\ decrease\ in\ \Phi$。&lt;/p>
&lt;p>注意到：$(total\ decrease\ in\ \Phi) \le (total\ increase\ in\ \Phi) = r+sd_{max}+3t$。&lt;/p>
&lt;p>因此总的运行时间最大为：$2r+2sd_{max}+4t$。&lt;/p>
&lt;p>因此插入的均摊复杂度为$O(1)$，减小键值的均摊复杂度为$O(1)$，提取最小值的均摊复杂度为$O(d_{max})$。&lt;/p>
&lt;h4 id="d_max限界分析">$d_{max}$限界分析&lt;/h4>
&lt;p>$d_{max}$为$d$的上界，限界即确定$d_{max}$与堆结点数目$n$的关系。&lt;/p>
&lt;p>考虑一颗$B_k$树，则其度$d=log_2n$，若堆中有多颗$B$树，相当于$n$增加，则其中一颗树的度$d&amp;lt;log_2n$。因此为了确定$d$的上界，堆中树越少越好，即只有一颗。&lt;/p>
&lt;p>考虑一颗$B_k$树，其度$d=log_2n$，若从其上摘下结点（减小键值操作），对单颗树来说，相当于$n$减小，则$d&amp;gt;log_2n$，当$n$最小时，此时取得最大的$d$。也可以考虑为$n$不变时，这种构成堆的方式（即单颗树且丢失最多的结点）可使$d$最大，即取到$d_{max}$。&lt;/p>
&lt;p>于是我们开始寻找各个度对应的最少结点树，不妨记其为$F_k$，$k$为度数：&lt;/p>
&lt;img src="images/image-20231122124352469.png" alt="image-20231122124352469" style="zoom: 50%;" />
&lt;img src="images/image-20231122124411709.png" alt="image-20231122124411709" style="zoom:50%;" />
&lt;img src="images/image-20231122124424160.png" alt="image-20231122124424160" style="zoom:50%;" />
&lt;img src="images/image-20231122124451912.png" alt="image-20231122124451912" style="zoom:50%;" />
&lt;img src="images/image-20231122124632445.png" alt="image-20231122124632445" style="zoom:50%;" />
&lt;p>回想二项树$B_{k+1}$由两颗$B_k$树构成：&lt;/p>
&lt;img src="images/image-20231122124742938.png" alt="image-20231122124742938" style="zoom:50%;" />
&lt;p>$F_{k+1}$树由$F_{k}$和$F_{k-1}$构成：&lt;/p>
&lt;img src="images/image-20231122125017065.png" alt="image-20231122125017065" style="zoom:50%;" />
&lt;p>尽管$|F_k|&amp;lt;|B_k|$，但不会小太多。$|F_k|\ge1.618^k$。&lt;/p>
&lt;p>对于斐波那契数列：
$$
f_k=f_{k-1}+f_{k-2},f_0=0,f_1=1
$$
注意到$|F_k|=f_{k+2}$，因为$|F_0|=f_2=1, |F_1|=f_3=2，|F_{k}|=|F_{k-1}|+|F_{k-2}|$。&lt;/p>
&lt;p>由斐波那契通项性质$f_{k+2} \ge \phi^k, \phi=\frac{1+\sqrt{5}}{2}=1.618&amp;hellip;$。&lt;/p>
&lt;p>考虑一个斐波那契堆含有$n$个结点，$T$为其中一颗树，其根结点度为$d$。&lt;/p>
&lt;p>则$n\ge|T|\ge|F_d|=f_{d+2}\ge\phi^d$。&lt;/p>
&lt;p>因此$d\le log_{\phi}n$。故$O(d_{max})=O(log_{\phi}n)=O(logn)$。&lt;/p>
&lt;p>因此提取最小值的均摊复杂度为$O(logn)$。&lt;/p></description></item><item><title>分治题解</title><link>https://chengyuan-artist.github.io/posts/divede_and_conquer_solution/</link><pubDate>Tue, 17 Oct 2023 11:21:52 +0800</pubDate><guid>https://chengyuan-artist.github.io/posts/divede_and_conquer_solution/</guid><description>&lt;img src="https://chengyuan-artist.github.io/posts/divede_and_conquer_solution/images/maxresdefault.jpg" alt="Featured image of post 分治题解" />&lt;p>朴东波算法课分治一节的算法作业及题解。&lt;/p>
&lt;h2 id="q1-两个升序数组的中位数">Q1 两个升序数组的中位数&lt;/h2>
&lt;blockquote>
&lt;p>你有兴趣分析来自两个独立数据库的一些难以获取的数据。每个数据库包含n个数值，因此总共有2n个值，你可以假设没有两个值是相同的。你想确定这组2n个值的中位数，我们将在这里将其定义为第n个最小值。但是，你可以访问这些值的唯一方法是通过对数据库的查询。在单个查询中，你可以为两个数据库之一指定一个值k，所选数据库将返回它包含的第k个最小值。由于查询很昂贵，因此你希望使用尽可能少的查询来计算中位数。给出一个最多使用O（logn）查询找到中位数的算法。&lt;/p>
&lt;/blockquote>
&lt;p>算法描述：记两个数据库中的数据分别构成集合$A$和$B$。&lt;/p>
&lt;p>取$A$中第$i$小的元素$a_i$，将$A$分成$A_L$ 和$A_R$两部分，其中&lt;/p>
&lt;p>$A_L= \lbrace a\mid a\in A, a&amp;lt;=a_i \rbrace$ ，$A_R= \lbrace a\mid a\in A, a&amp;gt;a_i \rbrace$。&lt;/p>
&lt;p>特别地，当$i=0$时，设$A_L=\emptyset$，$A_R=A$。&lt;/p>
&lt;p>同样，取$B$中第$j$小的元素$b_j$，将$B$分成$B_L$ 和$B_R$两部分，其中&lt;/p>
&lt;p>$B_L= \lbrace b\mid b\in B, b&amp;lt;=b_j \rbrace$，$B_R= \lbrace b \mid b\in B, b&amp;gt;b_j \rbrace$。&lt;/p>
&lt;p>特别地，当$j=0$时，设$B_L=\emptyset$，$B_R=B$。&lt;/p>
&lt;p>记$C_L=A_L\cup B_L$，$C_R=A_R\cup B_R$。&lt;/p>
&lt;p>当$|C_L|=|C_R|=n$ 且 $max(C_L) &amp;lt;= min(C_R)$时，题目所求的中位数即为$(max(C_L)+min(C_R))/2$。&lt;/p>
&lt;p>由$|C_L|=|C_R|=n$ 可得$i+j=n$，而$max(C_L)=max(a_{i},b_j)$，$min(C_R)=min(a_{i+1}, b_{j+1})$。算法只需要从$0$到$n$枚举$i$，当满足$max(a_{i},b_j)&amp;lt;=min(a_{i+1}, b_{j+1})$条件时即可得到中位数。&lt;/p>
&lt;p>采用二分法来枚举$i$。设$i_{min}=0$，$i_{max}=n$，令$i=(i_{min}+i_{max})/2$。&lt;/p>
&lt;p>若$a_i&amp;lt;=b_{j+1}$且$b_j&amp;lt;=a_{i+1}$，算法结束，返回中位数为$(max(a_{i},b_j)+min(a_{i+1}, b_{j+1}))/2$；&lt;/p>
&lt;p>若$a_i&amp;gt;=b_{j+1}$且$b_j&amp;lt;=a_{i+1}$，说明需要减小$i$，于是令$i_{max}=i-1$，继续二分$i$进行枚举；&lt;/p>
&lt;p>若$a_i&amp;lt;=b_{j+1}$且$b_j&amp;gt;=a_{i+1}$，说明需要减小$j$，即增大$i$，于是令$i_{min}=i+1$，继续二分。&lt;/p>
&lt;p>当$a_i&amp;gt;=b_{j+1}$时一定有$b_j&amp;lt;=a_{i+1}$，若当$a_i&amp;gt;=b_{j+1}$时$b_j&amp;gt;=a_{i+1}$，则有$a_i&amp;gt;=b_{j+1}&amp;gt;=b_{j}&amp;gt;=a_{i+1}$，与$a_{i}&amp;lt;=a_{i+1}$相矛盾。同理可证当$b_j&amp;gt;=a_{i+1}$时一定有$a_i&amp;lt;=b_{j+1}$，因此上述三种情况可以涵盖完毕。&lt;/p>
&lt;p>上述算法的伪代码如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">GetMedian&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nf">min&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]))&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中将对数组A，B的下标访问操作视作对数据库的一次查询操作。&lt;/p>
&lt;p>可以看到，每轮循环最多对数据库进行4次查询操作（假设重复查询存在缓存）则有时间复杂度$T(n)=T(n/2)+4$，由主定理可得$T(n)=O(logn)$。&lt;/p>
&lt;h2 id="q2-平面最近点对">Q2 平面最近点对&lt;/h2>
&lt;blockquote>
&lt;p>给定任意10个点，p1，p2，…，p10，在二维欧几里得平面上，请写一个算法来求最近的一对点之间的距离。&lt;/p>
&lt;p>（a）用蛮力算法来解决这个问题，分析你实现的蛮力算法的时间复杂度，并解释为什么算法的时间复杂度是$O(n^2)$，其中n是点数。&lt;/p>
&lt;p>（b）提出一种改进算法来解决这个问题，时间复杂度优于蛮力算法。描述算法的思想并分析其时间复杂度&lt;/p>
&lt;/blockquote>
&lt;h3 id="a">(a)&lt;/h3>
&lt;p>暴力算法：对每两个点计算距离，若距离小于当前最小值，则更新最小值。&lt;/p>
&lt;p>伪代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">minDist&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// P为点集，n为点的数量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">min_d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">INF&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">计算&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">两点的距离&lt;/span>&lt;span class="n">d&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">d&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">min_d&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">min_d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">d&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">min_d&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对于计算两点间距离的操作，算法共进行$n(n-1)/2$次，因此算法的时间复杂度为$O(n^2)$。&lt;/p>
&lt;h3 id="b">(b)&lt;/h3>
&lt;p>算法描述：&lt;/p>
&lt;p>设点集为$P$，首先将$P$中所有点按照以$x$坐标为第一关键字，$y$坐标为第二关键字从小到大进行排序。以中间点$p_m$的序号将点集分为两个集合$A$，$B$。对$A$和$B$分别调用本算法，得到点集$A$的结果$d_1$和点集$B$的结果$d_2$。&lt;/p>
&lt;p>令$d=min(d_1, d_2)$。设集合$C=\lbrace p_i\mid p_i\in P, |p_i.x-p_m.x|&amp;lt;=d\rbrace$，集合$C$中可能存在距离小于$d$且分别位于$A$和$B$的两点，因此求出集合$C$上的最短距离$d_c$，即可得到最短距离$d_{min}=min(d_c, d)。$&lt;/p>
&lt;p>对于集合$C$的任意一点$p_i$，设集合$D_i={p_j\mid p_j\in C, p_i.y&amp;lt;=p_j.y}$，求出$p_i$与$p_j$的距离并更新最短距离，即可求出点集$C$上的最短距离。&lt;/p>
&lt;p>将集合$C$按照$y$坐标由小到大排序，则集合$D_i$中的点为$p_i$的相邻几个点。可以设置集合$T=\empty$，从大到小枚举$p_i$，并从大到小枚举$p_j\in T$，枚举$p_j$过程中保证$p_j.y &amp;lt; p_i.y + d$，计算$p_i$与$p_j$间的距离并更新最小值，随后将$p_i$加入集合$T$，重复循环。可以看到在枚举过程中始终有$D_i \subseteq T$，且枚举$p_j$的集合恰好等于$D_i$。该算法保证没有多余的循环出现。&lt;/p>
&lt;p>算法的复杂度取决于合并阶段求集合$C$上最短距离的时间复杂度，而该复杂度取决于集合$D_i$的规模大小，下面将通过证明$|D_i|$为常数从而证明这个操作是$O(n)$的。&lt;/p>
&lt;img src="images/two.png" alt="img" style="zoom:50%;" />
&lt;p>如图绿色阴影区域为集合$D_i$。对于右边每个小正方形，其对角线长度为$\frac{d}{\sqrt{2}}$，因此小正方形中最多含有一个点，因此集合$D_i$除位于最下方边界处的点$p_i$外最多存在7个点，由此，求集合$C$上最短距离的时间复杂度为$O(7n)=O(n)$。&lt;/p>
&lt;p>此外，由于该算法要求集合$C$按照纵坐标排序，我们可以要求子问题将点集按照纵坐标排序，父问题只需要合并子问题的排序结果即可，合并排序的时间复杂度也为$O(n)$。故合并操作总的时间复杂度为$O(n)$。&lt;/p>
&lt;p>当子问题规模足够小$(n &amp;lt;= 3)$，即可暴力求解最短距离并排序点集。&lt;/p>
&lt;p>算法的时间复杂度$T(n)=2T(\frac{n}{2})+O(n)$，根据主定理可得$T(n)=O(nlogn)$。&lt;/p>
&lt;p>算法的伪代码如下：&lt;/p>
&lt;p>定义全局变量最短距离d，每次计算两点距离便更新一次d。使用缓冲区数组T来保存集合C。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">INF&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">minDist&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">right&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">计算&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">两点的距离并更新最小值&lt;/span>&lt;span class="n">d&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">以&lt;/span>&lt;span class="n">y为关键字排序点集P&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">minDist&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">minDist&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">m&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">以&lt;/span>&lt;span class="n">y为关键字归并左右两个集合的排序结果&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">创建点集数组&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t_len&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 反向建立集合C
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">m&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">d&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t_len&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">d&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">计算&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">两点的距离并更新最小值&lt;/span>&lt;span class="n">d&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">T&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">t_len&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">以&lt;/span>&lt;span class="n">x为第一关键字&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">y为第二关键字排序点集P&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">minDist&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="q3-快速次幂运算">Q3 快速次幂运算&lt;/h2>
&lt;blockquote>
&lt;p>给定一个整数n，其中100&amp;lt;n&amp;lt;10000，请设计一个高效算法计算$3^n$，时间复杂度不超过O（n）。&lt;/p>
&lt;p>（a）实现一个朴素数据口径计算$3^n$，并分析该朴素数据口径的时间复杂度。&lt;/p>
&lt;p>（b）提出一个改进算法计算$3^n$，时间复杂度不超过O（n）。描述算法的概念并分析其时间复杂度。&lt;/p>
&lt;/blockquote>
&lt;h3 id="a-1">(a)&lt;/h3>
&lt;p>将问题分割成n-1和1的子问题，即$f(n)=3*f(n-1)$，$f(1) = 3$。则递归或循环要进行n-1次，做n-1次乘法，时间复杂度为O(n)。&lt;/p>
&lt;h3 id="b-1">(b)&lt;/h3>
&lt;p>均匀地分割问题：&lt;/p>
&lt;p>$$
f(n)= \begin{cases} f(\frac{n}{2})*f(\frac{n}{2})&amp;amp; \text{n为偶数} \\ f(\frac{n-1}{2})*f(\frac{n-1}{2})*3&amp;amp; \text{n为奇数}\end{cases}, f(1) = 3
$$&lt;/p>
&lt;p>伪代码如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>时间复杂度$T(n) = T(\frac{n}{2})+c$，由主定理可得$T(n) = O(logn)$。&lt;/p>
&lt;h2 id="q4-反转二叉树">Q4 反转二叉树&lt;/h2>
&lt;blockquote>
&lt;p>给定一棵二叉树T，请给出一个O（n）算法来反转二叉树。例如下面，反转左二叉树，我们得到右二叉树。&lt;/p>
&lt;img src="images/binary_tree.png" alt="image-20231018203045181" style="zoom: 50%;" />
&lt;/blockquote>
&lt;p>算法描述：对于二叉树T，分别递归地调用本算法翻转左子树和右子树，随后交换左子树和右子树的索引。&lt;/p>
&lt;p>伪代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">invert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">invert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nf">invert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>时间复杂度分析：若二叉树为完全均匀的满二叉树，则时间复杂度$T(n)=2T(\frac{n}{2})+c$，由主定理可得$T(n)=O(n)$。对于一般情况，我们可以统计交换索引操作的次数。由伪代码可以看出，所有非空树结点都需要进行一次交换操作，由于存在n个树结点，因此操作数为n次，故时间复杂度为$O(n)$。&lt;/p>
&lt;h2 id="q5-越狱状态数">Q5 越狱状态数&lt;/h2>
&lt;blockquote>
&lt;p>一个监狱有N个房间，每个囚犯一个，有M个宗教，每个囚犯都会遵循其中一个。如果相邻房间的囚犯是同一宗教的，可能会发生越狱。请给出一个O（n）算法，找出可以发生多少个状态的越狱。例如，有3个房间和2种宗教，那么将发生6种不同的状态的越狱。&lt;/p>
&lt;/blockquote>
&lt;p>算法分析：&lt;/p>
&lt;p>记规模为n的问题解为E(n)。从题目的形式可以看出，如果知道了E(n)，E(n+1)将很容易地由E(n)推出。设想在n个牢房的最右端加入1间牢房，若前n间牢房已经满足越狱状态，则新加入牢房的犯人不论是何种信仰均不影响整体的越狱状态，对应$E(n)*m$种情况；若前n间牢房未满足越狱状态，此时对应前n间牢房的状态总数减去前n间牢房的越狱状态数，即$m^n-E(n)$，此时若想使整体达到越狱状态，第n+1间牢房就需要安排与第n间牢房信仰相同的犯人，因此该种情况下n+1牢房的越狱状态数与$(m^n-E(n))$一一对应。故
$$
E(n+1)=E(n)*m+m^n-E(n)=(m-1)*E(n)+m^n
$$
第一项为线性递归式，时间复杂度为线性的，注意到计算式中存在$m^n$，为了使整体的时间复杂度为线性的，可设$G(n)=m^{n}$，总体的表达式如下：&lt;/p>
&lt;p>$$E(n+1)=(m-1)*E(n)+G(n)，E(1) = 0$$&lt;/p>
&lt;p>$$G(n+1)=n*G(n)， G(1)=m$$&lt;/p>
&lt;p>算法的伪代码如下：(m为全局常数)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">Escape&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// return {E(n), G(n)}
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">e&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">g&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">Escape&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">g_next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">g&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">e_next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">m&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">e&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">g&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">e_next&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">g_next&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>每次递归共进行4次算术操作，共进行n-1次递归，故时间复杂度$T(n)=4(n-1)=O(n)$。&lt;/p></description></item><item><title>go get代理配置问题</title><link>https://chengyuan-artist.github.io/posts/go_proxy/</link><pubDate>Mon, 11 Oct 2021 11:23:57 +0800</pubDate><guid>https://chengyuan-artist.github.io/posts/go_proxy/</guid><description>&lt;p>记录下go get 配置代理的坑&lt;/p>
&lt;p>今天在&lt;code>yay yay&lt;/code>时，发现&lt;code>go build&lt;/code>时某几个包总是get不下来，遂研究半天。&lt;/p>
&lt;p>发现&lt;code>go get&lt;/code> 貌似不认&lt;code>ALL_PROXY&lt;/code>环境变量，只认&lt;code>http_proxy&lt;/code>和&lt;code>https_proxy&lt;/code>, 特别是&lt;code>https_proxy&lt;/code>要配好&amp;hellip;.&lt;/p>
&lt;p>OS第一节课搞了几十分钟。。。&lt;/p>
&lt;p>&lt;code>git&lt;/code>代理好像不用配，自动继承命令行代理。&lt;/p></description></item><item><title>WSL2下优雅使用Arch</title><link>https://chengyuan-artist.github.io/posts/archwsl/</link><pubDate>Mon, 27 Sep 2021 15:58:31 +0800</pubDate><guid>https://chengyuan-artist.github.io/posts/archwsl/</guid><description>&lt;p>记录Arch on wsl2的安装配置过程&lt;/p>
&lt;h2 id="archwslhttpsgithubcomyuk7archwsl下载安装">&lt;a class="link" href="https://github.com/yuk7/ArchWSL" target="_blank" rel="noopener"
>ArchWsl&lt;/a>下载安装&lt;/h2>
&lt;ol>
&lt;li>运行 Arch.exe 自动安装配置&lt;/li>
&lt;li>一个Arch就装好了！&lt;/li>
&lt;/ol>
&lt;h2 id="arch基本配置">Arch基本配置&lt;/h2>
&lt;blockquote>
&lt;p>使用&lt;code>wsl -d &amp;lt;Arch name&amp;gt;&lt;/code>进入Arch Bash Shell&lt;/p>
&lt;/blockquote>
&lt;h3 id="用户">用户&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>设置root密码&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@PC-NAME user&lt;span class="o">]&lt;/span>&lt;span class="c1"># passwd&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>添加用户&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@PC-NAME&lt;span class="o">]&lt;/span>&lt;span class="c1"># EDITOR=nano visudo&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> %wheel &lt;span class="nv">ALL&lt;/span>&lt;span class="o">=(&lt;/span>ALL&lt;span class="o">)&lt;/span> ALL
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">(&lt;/span>设置 sudoers 文件 uncomment the above line&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">(&lt;/span>保存 退出&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@PC-NAME&lt;span class="o">]&lt;/span>&lt;span class="c1"># useradd -m -G wheel -s /bin/bash {username}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>添加用户&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@PC-NAME user&lt;span class="o">]&lt;/span>&lt;span class="c1"># passwd {username}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>设置默认用户密码&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>设置默认用户&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-powershell" data-lang="powershell">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Arch&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="py">exe&lt;/span> &lt;span class="n">config&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="n">-default-user&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">username&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="pacman">Pacman&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>初始化密钥环（keyring） (必须执行此步骤才可以使用 Pacman)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>user@PC-NAME&lt;span class="o">]&lt;/span>$ sudo pacman-key --init
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>user@PC-NAME&lt;span class="o">]&lt;/span>$ sudo pacman-key --populate
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>修改pacman镜像源&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>user@PC-NAME&lt;span class="o">]&lt;/span>$ sudo vim /etc/pacman.d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>uncomment其中的China部分Server&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用Pacman滚系统&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>user@PC-NAME&lt;span class="o">]&lt;/span>$ sudo pacman -Syu
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="代理">代理&lt;/h3>
&lt;p>&lt;code>wsl2&lt;/code>网络与windows网络ip是分开的，这里实现代理的方法是让wsl2走win下的代理&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Clash客户端开启LAN&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">host_ip&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>cat /etc/resolv.conf &lt;span class="p">|&lt;/span>grep &lt;span class="s2">&amp;#34;nameserver&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span>cut -f &lt;span class="m">2&lt;/span> -d &lt;span class="s2">&amp;#34; &amp;#34;&lt;/span>&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">export&lt;/span> &lt;span class="nv">ALL_PROXY&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;http://&lt;/span>&lt;span class="nv">$host_ip&lt;/span>&lt;span class="s2">:7890&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>导入&lt;code>.bashrc&lt;/code>或你正在使用的shell的配置文件（如&lt;code>.zshrc&lt;/code>)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">source&lt;/span> ~/.bashrc
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>&lt;code>/etc/resolv.conf&lt;/code> 保存了wsl的ip地址，由wsl每次运行时（猜测）自动生成&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>基本配置到这里就做好了。&lt;/p></description></item><item><title>Hugo博客搭建</title><link>https://chengyuan-artist.github.io/posts/blog_creation/</link><pubDate>Thu, 23 Sep 2021 23:02:40 +0800</pubDate><guid>https://chengyuan-artist.github.io/posts/blog_creation/</guid><description>&lt;p>记录Hugo博客搭建的过程&lt;/p>
&lt;h1 id="博客搭建">博客搭建&lt;/h1>
&lt;blockquote>
&lt;p>本文初步设定按照时间顺序，记录博客搭建的过程和踩过的坑，以及过程中学会的新姿势（&lt;/p>
&lt;/blockquote>
&lt;h2 id="技术栈选择">技术栈选择&lt;/h2>
&lt;blockquote>
&lt;p>Hugo + GitHub Page&lt;/p>
&lt;/blockquote>
&lt;p>搭博客这个想法年初就有了，git仓库也建好了，结果一直咕到现在。。。&lt;/p>
&lt;p>搭之前参考了一下周围同龄人大佬的技术栈，基本上分为Hexo和Hugo两类。逛了一下Hugo git仓库发现是拿go写的，果断选择Hugo（不得不说，go确实优美）。也是早早听说Github有免费托管网页的功能，因为相较其他部署方法（服务器Netlify等）感觉比较方便，所以选择了Github page。&lt;/p>
&lt;p>直到暑假NUS夏令营接触了一下云服务器，开学看了计网自顶而下的应用层部分，才知道HTTP协议，网络应用通信的基本原理有多简单。后悔没有早点了解，一直云里雾里。&lt;/p>
&lt;h2 id="hugo安装">Hugo安装&lt;/h2>
&lt;blockquote>
&lt;p>Windows 11&lt;/p>
&lt;/blockquote>
&lt;p>一定要记得下载extend版本，非extend版本不支持Sass/SCSS扩展&lt;/p>
&lt;p>Hugo并不提供installer安装版本，需要自行从git仓库下载对应版本安装包并解压。&lt;/p>
&lt;p>对于具体的安装，&lt;a class="link" href="https://gohugo.io/getting-started/installing/" target="_blank" rel="noopener"
>官方文档&lt;/a>还贴心地给出了面对Technical Users和Less-technical Users的不同教程（，然而在Technical Users一栏在PowerShell中配置Path的方法是临时的。好奇PowerShell有没有像Linux &lt;code>.bashrc&lt;/code>配置文件一样的东西，经过一番google发现确实有，Ps用一个叫profile的文件管理启动配置。于是马上按&lt;a class="link" href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_profiles?view=powershell-7.1#how-to-create-a-profile" target="_blank" rel="noopener"
>文档&lt;/a>来创建。&lt;/p>
&lt;p>创建&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-powershell" data-lang="powershell">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(!(&lt;/span>&lt;span class="nb">Test-Path&lt;/span> &lt;span class="n">-Path&lt;/span> &lt;span class="nv">$PROFILE&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">New-Item&lt;/span> &lt;span class="n">-ItemType&lt;/span> &lt;span class="n">File&lt;/span> &lt;span class="n">-Path&lt;/span> &lt;span class="nv">$PROFILE&lt;/span> &lt;span class="n">-Force&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>编辑&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-powershell" data-lang="powershell">&lt;span class="line">&lt;span class="cl">&lt;span class="n">code&lt;/span> &lt;span class="nv">$PROFILE&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>配置&lt;code>.ps1&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-powershell" data-lang="powershell">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">InitPath&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">$env:Path&lt;/span> &lt;span class="p">+=&lt;/span> &lt;span class="s2">&amp;#34;;D:\Coding\Hugo\bin&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">InitPath&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>研究了一下，Ps的&lt;code>$env:path&lt;/code>变量保存的初值是系统path+用户path，这条语句只会改变当前ps命令行的path值，不会影响系统变量。&lt;/p>
&lt;/blockquote>
&lt;p>兴高采烈打开新Ps窗口，结果一大堆红字就跳了出来，貌似是没有脚本运行权限。又search一番发现，原来ps默认禁止配置脚本运行（晕。查阅有关&lt;a class="link" href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.1" target="_blank" rel="noopener"
>文档&lt;/a>，在Ps中&lt;code>Get-ExecutionPolicy&lt;/code>的默认值为&lt;code>Restricted&lt;/code>，不允许任何配置脚本文件运行，把此值改为&lt;code>RemoteSigned&lt;/code>即可&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-powershell" data-lang="powershell">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">Set-ExecutionPolicy&lt;/span> &lt;span class="n">-ExecutionPolicy&lt;/span> &lt;span class="n">RemoteSigned&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>&lt;code>RemoteSigned&lt;/code>默认为Windows server的权限属性&lt;/p>
&lt;p>&lt;code> Restricted&lt;/code>默认为Windows client的权限属性（安全性考虑？普通用户真就不当人呗）&lt;/p>
&lt;/blockquote>
&lt;p>至此，Hugo终于安装好了。&lt;/p>
&lt;p>&lt;code>ArchLinux&lt;/code>的安装只需要一行&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo pacman -Syu hugo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>泪目了&lt;/p>
&lt;p>按照传统异能&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-powershell" data-lang="powershell">&lt;span class="line">&lt;span class="cl">&lt;span class="n">hugo&lt;/span> &lt;span class="n">version&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>显示&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">hugo v0.88.1-5BC54738+extended windows/amd64 BuildDate=2021-09-04T09:39:19Z VendorInfo=gohugoio
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="hugo配置">Hugo配置&lt;/h2>
&lt;p>Hugo使用&lt;code>config.toml&lt;/code>文件来进行具体配置。除了一些通用配置外，剩下的配置基本都是根据你选定的主题xjb魔改就行了。例如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">hugo new site blog
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cd blog
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>初始化git仓库&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">git init
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>主题最好以submodule的形式添加，便于更新&lt;/p>
&lt;p>这里在&lt;code>themes&lt;/code>文件夹下添加了&lt;a class="link" href="https://github.com/dillonzq/LoveIt/" target="_blank" rel="noopener"
>LoveIt&lt;/a>主题&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在配置文件&lt;code>config.toml&lt;/code>中添加&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-toml" data-lang="toml">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">theme&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;LoveIt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>剩下的配置按照&lt;a class="link" href="https://hugoloveit.com/zh-cn/theme-documentation-basics/#basic-configuration" target="_blank" rel="noopener"
>LoveIt官方文档&lt;/a>和&lt;code>themes/LoveIt&lt;/code>目录下的&lt;code>exampleSite&lt;/code>魔改即可。&lt;/p>
&lt;p>对于文章创建，Hugo使用&lt;code>Archetypes&lt;/code>下的模板为你生成博客文件，不同主题都有自己不同的模板，使用命令&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">hugo new posts/first_post.md
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>即可按照模板生成文档。&lt;/p>
&lt;p>或者，&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">hugo new posts/first_post/index.md
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这样便于将图片等资源放在文档同一目录下，便于索引。见Hugo文档&lt;a class="link" href="https://gohugo.io/content-management/page-bundles/#leaf-bundles" target="_blank" rel="noopener"
>Leaf Bundles&lt;/a>&lt;/p>
&lt;p>另外，在查文档时还了解到用日期年月日来形成url索引文章的方式，如 9/23/21/hello.md。有空再去了解&lt;/p>
&lt;p>在配置网站的过程中，使用&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">hugo server -D
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以实时查看网站的变化&lt;/p>
&lt;p>当调整满意后，使用&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">hugo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>生成静态网站，默认输出在&lt;code>public&lt;/code>目录&lt;/p>
&lt;h2 id="部署">部署&lt;/h2>
&lt;p>一开始的想法是在Github建两个仓库，一个存网站Hugo源码，gitignore&lt;code>public&lt;/code>文件更新；另一个以&lt;code>username.github.io &lt;/code>命名的仓库上传&lt;code>public&lt;/code>的内容，逻辑看起来很清晰，对吧。但一开始直接犯蠢把Hugo源码发到&lt;code>username.github.io&lt;/code>仓库了，结果Github page部署选择没法选&lt;code>public&lt;/code>子文件，由于git姿势不够，遂把整个库删了&amp;hellip; 后来搞了两个仓库，又忘记ignore&lt;code>public&lt;/code>，直接在&lt;code>public&lt;/code>下新建git仓库，当时就感觉有点不对劲，因为这样的操作会导致&lt;code>public&lt;/code>文件下的每个更新都会影响到整颗文件树，而本意是希望二者相对独立互不干扰（虽说加了gitignore当前情境下就没问题了，但毕竟是个一般性问题）。参考了&lt;a class="link" href="https://zhuanlan.zhihu.com/p/37752930" target="_blank" rel="noopener"
>这篇博客&lt;/a>，发现git还有&lt;code>git worktree add&lt;/code>操作，就是为了解决上述问题，新姿势get。&lt;/p>
&lt;p>这篇博客中提出了两种部署方法&lt;/p>
&lt;ol>
&lt;li>
&lt;p>将hugo输出文件的默认文件夹名称改为docs&lt;/p>
&lt;p>只需要在&lt;code>config.toml&lt;/code>中添加&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-toml" data-lang="toml">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">publishDir&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">docs&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>即可&lt;/p>
&lt;p>随后可以直接修改GitHub page部署&lt;code>docs&lt;/code>下的网页。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在&lt;code>public&lt;/code>文件夹下建立独立分支&lt;/p>
&lt;p>配置GitHub page部署该独立分支的内容&lt;/p>
&lt;p>代码如下（示例）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">//忽略public子目录
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">echo &amp;#34;public&amp;#34; &amp;gt;&amp;gt; .gitignore
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//初始化publish branch
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout --orphan publish
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reset --hard
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit --allow-empty -m &amp;#34;init publish branch&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin publish
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout main
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 部署
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rm -rf public
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mkdir public
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rm -rf .git/worktrees/public/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 在public下建立publish独立分支pulish
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// index reset 至远端 publish
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git worktree add -B publish public origin/publish
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">hugo
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cd public
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git add --all
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit -m &amp;#34;some words&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin publish
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个方法的好处是可以将源文档和生成的网页文档的版本历史&lt;strong>分开控制&lt;/strong>&lt;/p>
&lt;p>有关git worktree 相关知识，下篇博客总结一下（咕咕咕&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>发现Netlify不仅有CDN服务器，还支持git仓库自动部署，直接run去Netlify了 (逃)&lt;/p></description></item><item><title>关于</title><link>https://chengyuan-artist.github.io/about/</link><pubDate>Mon, 20 Sep 2021 19:45:13 +0800</pubDate><guid>https://chengyuan-artist.github.io/about/</guid><description>&lt;h2 id="标签">标签&lt;/h2>
&lt;p>某985 计算机科学与技术 学士&lt;/p>
&lt;p>某研究所 体系结构 硕士在读&lt;/p>
&lt;h2 id="序言">序言&lt;/h2>
&lt;p>欢迎你，陌生人！感谢你愿意花上几分钟来了解我，在内容爆胀的时代，能够在这里相遇属实是难得的缘分。不妨把这里当作闲暇外出时偶尔推门进入的咖啡小馆，点上一杯咖啡——或是麦茶，听听店长我的闲言碎语。&lt;/p>
&lt;p>为什么要开始写博客呢？故事起源于对极客的憧憬，然而一度终结于才疏学浅和懒。经历了起起伏伏，最终决定重拾极客的梦。设立博客的目的主要是为了践行 “边学习边输出”，加深自己的理解，以及期望偶尔深度内容的产出。如果某篇博客能给你带来启发或帮助，那就再好不过了；如果能在评论区指出我理解的不妥或错误，我会万分感激！&lt;/p>
&lt;p>博客目前重新开张，我会努力经营，感谢你的支持。&lt;/p>
&lt;h2 id="闲暇">闲暇&lt;/h2>
&lt;p>喜欢看番。&lt;/p>
&lt;p>印象最深刻且对我影响最大的番剧：&lt;/p>
&lt;ul>
&lt;li>《吹响！上低音号》&lt;/li>
&lt;li>《进击的巨人》&lt;/li>
&lt;li>《命运石之门》&lt;/li>
&lt;li>《86-不存在的战区》&lt;/li>
&lt;li>《EVA》全系列&lt;/li>
&lt;li>《乒乓》&lt;/li>
&lt;li>《辉夜大小姐想让我告白》剧场版&lt;/li>
&lt;/ul>
&lt;p>另外还有许多我认为非常不错的佳品不在这里一一列举。后续也许会出些漫评？有生之年总会有的（&lt;/p>
&lt;hr>
&lt;p>喜欢听日语流行歌，90-10年代华语歌曲，周杰伦。&lt;/p>
&lt;p>看LOL比赛。最敬佩的选手是Faker。&lt;/p></description></item><item><title>Hello World</title><link>https://chengyuan-artist.github.io/posts/hello_world/</link><pubDate>Mon, 20 Sep 2021 16:36:52 +0800</pubDate><guid>https://chengyuan-artist.github.io/posts/hello_world/</guid><description>&lt;h1 id="hello-world">Hello World!&lt;/h1>
&lt;p>This is the first blog. It has 3 points:&lt;/p>
&lt;ol>
&lt;li>simple&lt;/li>
&lt;li>clear&lt;/li>
&lt;li>nice&lt;/li>
&lt;/ol>
&lt;p>中文测试&lt;/p></description></item><item><title>归档</title><link>https://chengyuan-artist.github.io/archives/</link><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><guid>https://chengyuan-artist.github.io/archives/</guid><description/></item><item><title>Archive</title><link>https://chengyuan-artist.github.io/archive/</link><pubDate>Sat, 19 Aug 2017 21:37:49 +0800</pubDate><guid>https://chengyuan-artist.github.io/archive/</guid><description/></item><item><title>搜索</title><link>https://chengyuan-artist.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://chengyuan-artist.github.io/search/</guid><description/></item><item><title>友链</title><link>https://chengyuan-artist.github.io/links/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://chengyuan-artist.github.io/links/</guid><description>&lt;p>有空再加，咕咕古&lt;/p></description></item></channel></rss>