[{"content":"在编译SPDK应用程序时，有时需要使用静态链接SPDK库的版本。\n有时甚至需要完全静态链接（包括静态链接系统库，libc等）的版本。\n用于特定TEE环境，无动态库甚至无完整操作系统支持\n去网上查询，没有直接SPDK静态链接的解决办法。探索了一番后，把我的做法总结上来。\n注意：本文的解决方案在于完全静态链接SPDK程序（包括libc）, 如果你寻找的是仅静态链接SPDK库的方法，请参考Linking SPDK applications with pkg-config。\nTL;DR 以SPDK自带的spdk_nvme_perf应用为例。\n首先按照正常流程编译DPDK和SPDK。\n对于交叉编译（以RISC-V为例），先交叉编译DPDK并安装到路径/path/to/dpdk/bin，随后如下编译SPDK:\n进入SPDK根目录：\n1 2 3 4 export CC=riscv64-linux-gnu-gcc export CXX=riscv64-linux-gnu-g++ ./configure --target-arch=rv64gc --cross-prefix=riscv64-linux-gnu --with-dpdk=/path/to/dpdk/bin make -j($nproc) 进入SPDK_ROOT/app/spdk_nvme_perf\n编辑Makefile 在尾部添加\n1 2 3 4 5 6 7 8 9 PKG_CONFIG_PATH = $(SPDK_ROOT_DIR)/build/lib/pkgconfig SPDK_LIB := $(shell PKG_CONFIG_PATH=\u0026#34;$(PKG_CONFIG_PATH)\u0026#34; pkg-config --libs spdk_nvme spdk_env_dpdk spdk_vmd) SYS_LIB := $(shell PKG_CONFIG_PATH=\u0026#34;$(PKG_CONFIG_PATH)\u0026#34; pkg-config --libs --static spdk_syslibs) static: $(CC) -o $(SPDK_ROOT_DIR)/build/bin/perf-static perf.o \\ -static -static-libgcc \\ -Wl,--whole-archive $(SPDK_LIB) \\ -Wl,--no-whole-archive $(SYS_LIB) 执行\n1 make static 即可获得位于$(SPDK_ROOT_DIR)/build/bin/perf-static的静态链接可执行文件。\n解析 pkg-config pkg-config是一个编译辅助工具，用于确定第三方库的位置以获取正确的链接位置和编译命令。需要配合环境变量PKG_CONFIG_PATH使用以指向第三方库提供的*.pc文件。\nPKG_CONFIG_PATH = $(SPDK_ROOT_DIR)/build/lib/pkgconfig即SPDK库的pakage config所在位置。\npkg-config --libs spdk_nvme spdk_env_dpdk spdk_vmd命令给出了spdk_nvme,spdk_env_dpdk和spdk_vmd三个库的链接命令，这些库的源文件位于$(SPDK_ROOT_DIR)/lib。\n命令PKG_CONFIG_PATH = $(SPDK_ROOT_DIR)/build/lib/pkgconfig pkg-config --libs spdk_nvme示例输出:\n1 -L/path/to/build/lib -lspdk_nvme -lspdk_sock -lspdk_sock_posix -lspdk_trace -lspdk_rpc -lspdk_jsonrpc -lspdk_json -lspdk_util -lspdk_vfio_user -lspdk_log pkg-config --libs --static spdk_syslibs命令给出了SPDK库所需链接的系统库。\n编译选项 -static 静态链接全局选项，所有库会进行静态链接。如果只想对部分库进行静态链接，可以使用-Wl,-Bstatic和-Wl,-Bdynamic 包裹要进行静态链接的库链接命令。\n-static-libgcc 静态链接libgcc\n-Wl, --whole-archive 给链接器传递的指令，强制将后面指定的静态库的所有对象文件都包含到最终的可执行文件中（包括未被引用的符号）\n-Wl,--no-whole-archive 禁用 --whole-archive 的行为\n我尝试了许多不同命令组合，最终上文那种是最小的有效命令。\n碎碎念\n本文是今年7月份帮师兄做实验的时候就打算写的一篇小trick, 拖到现在才写，坏处就是回顾了半天才想起来当时的做法。下次还是要更勤快些，现解决，现分享 :p\n参考 Linking SPDK applications with pkg-config SPDK Libraries: #SPDK Static Objects compile statically linked dpdk apps ","date":"2024-12-09T16:48:38+08:00","permalink":"https://chengyuan-artist.github.io/posts/spdk_static_link/","title":"SPDK应用静态链接"},{"content":"上周五看的电影，晚上写的影评，硬生生拖到现在才发（\n印象深刻的场景 极致的浪漫！大海，天空，白云，飞艇。\n为什么是猪？ 主人公为什么会变成猪。猪是懒惰，散漫又毫无责任感的象征。主人公正是被时代/政府视作懒散不负责任，因为在那个经济低迷，战火和冲突纷发的年代，个人唯有将其全部价值奉献给民族和国家，才是时代/政府眼中负责任的做法，主人公作为原空军本领高强的飞行高手，却不为国家出力，而是隐居荒岛靠赏金为生，因此才被时代/政府定义成猪。\n但懒惰，散漫和毫无责任感这些词语的背后，正是宝贵的自由。自由地在大海和蓝天之中遨游，自由地追求和捍卫飞行员的荣耀，不受国家和法律的约束，不必与他人自相残杀，不必眼睁睁而又无可奈何地看着昔日的战友死去。需要牵挂的，只有一位老朋友，做自由的游侠，也并不耽误每晚酒会与老友的会面。可以说，主人公是自愿变成“猪”的。\n但自由有其代价，红猪所选择的自由之路是终究不会被时代和政府承认的。卖汽油店里的老人对主人公说靠他的能力加入组织中一定能赚大钱；军队中的旧识也希望主人公能重归部队，至少在部队中有人脉可以保护他。但红猪知道自己要走什么路，也知道自己的路如何凶险和艰难。这也是为何他坚决不让机械师小姐跟随自己踏上自己的道路；对心上人吉娜也始终以敬爱的朋友之情相对，尽管从宿敌卡吉士口中了解到吉娜对自己的心意，在这个无法给予心上人幸福保证的时代，主人公也无法轻易地迈出这一步。\n幸运的是，当时代悄然改变，能够宽容自由之日，那主人公也就不会再是猪的形态。结尾红色的机翼，吉娜并不在白天的私人花园，似乎暗示着红猪不同以往的结局。祝福他们，并向浪漫和自由致敬！\n另外，对于来自美国的卡吉士其人，也并非穷凶极恶的反派，反而也是同样追求着自由，荣耀，爱情，甚至带些天真和傻气。吉娜之言“你没有经历过我们所经历的”。没有沉重的包袱，反而能飞的更高更远，最终与红猪也几乎不分胜负。但没有经历与成长，无法成为真正的男人，也是为何他被吉娜拒绝：“请你自己去好莱坞吧，小男孩”，也是为什么红猪能最终走入吉娜心中。\n","date":"2023-11-25T19:18:12+08:00","image":"https://chengyuan-artist.github.io/posts/movie_porco_rosso/images/image-20231126000336734_hu5237532904089274789.png","permalink":"https://chengyuan-artist.github.io/posts/movie_porco_rosso/","title":"《红猪》“因为他们的心，被大海和蓝天洗过” "},{"content":"优先队列 动机 某些情况下，我们需要频繁地动态地取出一个集合S中的最小元素/最大元素。\n这里动态指我们需要在集合S上执行插入/删除/更改键值操作。\n问题在于如何组织数据结构使这些操作更高效。\n操作定义 以最小优先队列为例：\n方法名 描述 MakeHeap() 建立一个堆H Insert(H, x) 在堆H中插入元素x ExtractMin(H) 提取堆H中的最小元素 DecreaseKey(H, x, k) 减小堆中元素x的键值为k Union(H1 , H2 ) 返回一个新堆包含H1和H2的所有元素，销毁输入堆 应用举例 Dijkstra单源最短路算法：需要ExtractMin Prim最小生成树算法：需要ExtractMin与DecreaseKey Why we need Union? 数组/链表实现 我们可以用数组或链表快速实现一个简单版本的优先队列。\n由于本篇偏向理论分析，因此更在意数据结构的逻辑结构而非物理结构。对以下两种实现方式而言，可以认为数组的逻辑结构和链表相同（实际上二者复杂度分析也相同），因此都用链表代替。\n无序链表实现 每次都在首部插入新元素；提取最小值时，遍历链表找到最小值并更改链表指针将其从链表中删除。\n（数组版本）每次在尾部插入新元素；提取最小值时，遍历数组找到最小值并将其与尾部元素交换位置，减小长度计数。\n复杂度：\n插入操作：$O(1)$ 提取最小值：$O(n)$ 有序链表实现 插入新元素时，遍历链表至第一个大于其的元素位置处，在此之前插入；提取最小值直接返回首部，并将其删除（更改头指针）。\n（数组版本）倒序维护数组大小，插入新元素时，遍历链表至第一个小于其的元素位置处，在此之前插入，后续元素后移；提取最小值时直接返回尾部，并将其删除（减小长度计数）。\n复杂度：\n插入操作：$O(n)$ 提取最小值：$O(1)$ 问题 是否存在使得插入和提取最小值时间复杂度更均衡/更优的数据结构？\n二叉堆 观察有序链表实现，插入操作实际上每次都在进行插入排序以维持整个链表的有序，然而这属于工作过头了，我们只需要维护一个最小值。\n有序链表的每个指针指向的元素都大于等于自身，数据结构限制过于严格，因此需要放松限制。 但限制不能过分放松，否则就会像无序链表那样，元素间没有任何限制，导致提取操作复杂度上升。 二叉堆：\n逻辑结构：一颗二叉树，且父结点小于子结点。所有结点除最后一层外按照完全二叉树排列。 物理结构：为了便于随机读取以及减少指针开销。结点以完全二叉树编号为下标放入数组中。\n因此对结点$i$ ，左子结点下标为$2i$，右子结点下标为$2(i + 1)$，父结点下标为$ (i-1)/2$（向下取整）。下标越界时，表示结点不存在。\n操作：\n插入：将新元素置于二叉堆尾部，依次向上调整，使得最小堆性质（父结点小于子结点）保持。由于二叉堆高为$log_2n$（$n$为元素个数），因此时间复杂度为$O(logn)$。\n提取最小值：将堆顶元素与堆尾元素交换，减小堆数组长度计数，从根结点开始依次向下调整，使得最小堆性质保持。时间复杂度为$O(logn)$。\nDecreaseKey(x, k)：将下标x处元素值降低为k。从该元素开始依次向上调整。时间复杂度为$O(logn)$。\n建堆：\n通过建空堆依次入堆。时间复杂度$O(nlogn)$。\n通过\u0026quot;遍历堆化\u0026quot;实现。将所有元素原封不动地入堆，随后调整堆结构。\n方法：按照完全二叉树编号从尾结点开始向根结点依次调用“向下调整”。\n时间复杂度：将堆补充为完全二叉树，不影响复杂度计算。设层高为$d = log_2n$。从上到下依次为第0\u0026hellip;d层。对第i层，操作总次数为$2^i*(d-i)$​。因此总操作数 $$ T(n)=2^0d+2^1(d-1)+2^2(d-2)\u0026hellip;+2^{d-1} $$\n$$ 2T(n)=2^1d+2^2(d-1)+\u0026hellip;+2^{d} $$\n故 $$ T(n)=2^1+2^2+\u0026hellip;+2^d -d=2\\frac{1-2^d}{1-2}-d=2^{d+1}-d-2=O(2^{d+1})=O(n) $$\n合并：将两个堆的数据组成一个堆，再遍历堆化。$O(n)$。\n至此，我们得到了插入，提取，改键均为$O(logn)$，且合并为$O(n)$的堆。实现简单且复杂度不错。\n问题 如果想进一步降低合并的复杂度，该怎样调整数据结构？\n二项式堆 观察二叉堆的逻辑结构，我们发现只允许一棵树存在这一限制。因此在两个堆合并时，需要拆散两颗树合并为一颗。如果允许多棵树存在，逻辑结构不是一棵树而是森林。合并时无需破坏原有堆的结构。\n放松限制：一棵树 -\u0026gt; 允许森林 不要过分放松：同类型的树只存在一颗。 综上，既然允许多棵树存在，插入操作就变成了合并操作，即合并一颗只含根结点的树，直接将其插入森林中即可；由于同类型的树只能有一颗，我们需要合并同类型的树，合并后的树也应该属于某个类型。\n二项树 定义：$B_k$为二项式树，定义$k$为$B_k$的度数。\n$B_0$只含有一个结点 两个$B_k$可以合并为$B_{k+1}$ 这里合并操作指将$B_k$作为另一$B_k$的根结点的儿子插入。\n这样的定义使二项树有一些有趣的性质：\n$B_k$树层高为$k$ $B_{k}$树的每个子结点分别为$B_0,B_1,\u0026hellip;,B_{k-1}$ （$B_k$树的第$i$个子结点的度为$i-1$） $B_k$树的每层结点个数正好是$k$的二项式系数（$(a+b)^k$）（命名来源） $|B_k|=2^k$ 二项堆 定义：二项堆为二项树组成的森林\n其中每个度数的二项树只有一颗 对于二项堆中的每颗二项树，满足最小堆性质 由此，当二项堆里有相同类型的二项树需要合并时，取根结点最小的树的根结点作为父结点，将另一棵树作为其儿子插入。\n二叉堆二项树根结点用双向链表连接，指针指向最小的根结点。\n二项堆也有一些有趣的性质：\n对于规模为$n$的二项堆，其二项树的组合是确定的。二项堆含有$B_i$当且仅当$b_i=1$，其中$(b_kb_{k-1}\u0026hellip;b_0)_2=n$。 二项堆最多含有$log_2n$（向下取整）颗二项树 二项堆的层高不超过$log_2n$（向下取整） 操作：\n插入：合并一颗$B_0$树。最好情况下$O(1)$，最坏情况下$O(logn)$，均摊复杂度为$O(1)$。这是什么？别急 提取最小值：将最小根结点取出，将该二项树拆为其所有子树，合并相同类型的二项树。$O(logn)$。 合并：复杂度$O(logn)$，均摊复杂度$O(1)$。 减小键值：在某颗二项树上向上调整。$O(logn)$。 均摊分析 为什么要均摊分析？在分析插入/合并/提取最小值时，我们总考虑工作量的上限，即最坏情况，推出复杂度均为$O(logn)$。但是这三个操作复杂度在时间上具有继承性，如果做了一次工作量较大的操作，随后许多次操作都只需要很小的工作量。这种情况下可以引入势能分析。\n插入 伪代码：\n1 2 3 4 5 6 7 8 Insert(x) { Creat a B0 tree for x; Change the pointer to the min root; while (there are two Bk tree for some k) { Link them into one Bk+1 tree; Change the pointer to the min root; } } 一次插入操作需要消耗$1+w$时间，$w=\\#while$ 是while语句执行的数量，$\\#$表示number of。\n引入势函数$\\Phi=\\#tree$，即二叉堆中树的数量。当进行一次插入操作后，势函数可以分为上升的部分和下降的部分。\n上升：$1$ 下降：$w$，即树减少的数量 因此一次插入操作需要$1+decrease\\ in\\ \\Phi$。而由于$\\Phi\u0026gt;=0$，故$all\\ decrease\\ in\\ \\Phi \u0026lt;= all\\ increase\\ in\\ \\Phi$。这为我们统计一系列操作提供了方便。\n可以看到，当分析合并时，伪代码与插入只有第二行的区别，一次合并操作需要的时间也是$1+decrease\\ in\\ \\Phi$。\n提取最小值 伪代码：\n1 2 3 4 5 6 7 8 ExtractMin(H) { Remove the min node and insert its children to the root list; Change the pointer to the min node; while (there are two Bk tree for some k) { Link them into one Bk+1 tree; Change the pointer to the min root; } } 一次操作需要消耗$d+w$，$w=\\#while$，$d$为去除根结点的树的度（也是其子树数量）。\n我们用同样的势函数$\\Phi=\\#tree$。进行一次操作，势函数既有上升的部分也有下降的部分。\n上升：$d$ 下降：$w$ 因此一次操作需要$d+decrease\\ in\\ \\Phi$。其中$d\u0026lt;=log_2n$。\n分析 若对一个二叉堆做了$a$次插入操作和$b$次提取最小值操作，总消耗的时间\n$$ \\begin{align*} T(a,b)\u0026amp;= a(1+decrease\\ in\\ \\Phi)+b(d+decrease\\ in\\ \\Phi) \\\\\\ \u0026amp;\\le a(1+increase\\ in\\ \\Phi)+b(d+increase\\ in\\ \\Phi) \\\\\\ \u0026amp;=a+bd+all\\ increase\\ in\\ \\Phi \\\\\\ \u0026amp;=a+bd+a+bd=2a+2bd \\\\\\ \u0026amp;\\le 2a+2blogn \\end{align*} $$ 由于$n$与$m$无关，因此插入操作的均摊复杂度为$O(\\frac{T(a)}{a})=O(1)$，提取最小值的操作的均摊复杂度为$O(\\frac{T(b)}{b})=O(logn)$。合并操作均摊复杂度与插入操作相同，为$O(1)$。\n问题 对比二叉堆，我们成功地将合并操作的复杂度降低为$O(1)$（均摊）。如果进一步考虑，如何降低减小键值的复杂度呢？\n斐波那契堆 对于减小键值操作，无论是二叉堆还是二项堆，都避免不了对堆进行调整的操作。为了降低复杂度，能否进行操作后，不进行或推迟调整操作？\n斐波那契堆在二项堆的基础上：\n放松限制，允许同类型的二项树共存；同时在减小键值操作后，并不调整堆而是直接将该结点及其子树摘下放入根结点列表中，同时给该结点的父结点打上标记，已表明该父节点“失去”过一个结点。（1）\n注意到该限制不是完全放松的，对每颗二项树而言，非根结点最多失去一个结点。（2）\n“摘下”操作相当于取消了原来的堆调整过程，将其推迟到堆做合并时。减小键值对应着摘下结点。\n当已被标记的结点的子结点被摘下后，该结点应取消标记并也被摘下，递归地向父结点进行直至没有标记。\n根结点不允许失去结点 -\u0026gt; 便于统计树的度数 。\n注意到由于条件（1）的存在，插入和合并都只需向根结点列表中添加新的树即可。但堆总要做出调整，何时？\n答案是不得不调整时，即提取最小值后，此时无论如何都要进行合并操作了，否则根结点列表数量将膨胀。\n合并操作是合并相同度数的树。树的度数等于根结点的子结点数目。\n操作：\n插入：合并一颗$B_0$树。复杂度$O(1)$。 提取最小值：将最小根结点取出，将拆为其所有子树并插入根结点列表。最坏\u0026amp;均摊$O(logn)$。为什么？ 合并：复杂度$O(1)$。 减小键值：均摊复杂度$O(1)$。 均摊分析 提取最小值 伪代码：\n1 2 3 4 5 6 7 8 ExtractMin() { Remove the min node and insert its children to the root list; Change the pointer to the min node; while (there are two roots u and v of the same degree) { Consolidate the two trees together; Change the pointer to the min root; } } 与二叉堆的操作相同，但这里我们使用新的势函数$\\Phi=\\#tree+2\\#mark$，$\\#mark$为被标记的非根结点数量。 why?\n一次提取最小值操作带来的势函数变化为：\n上升（静态）：$d$（移除结点的度） 下降（动态）：$w$ 一次操作需要$d+decrease\\ in\\ \\Phi$，$d$为根结点的度。\n注意到由于树会被摘下结点，因此$d$有可能大于$log_2n$。\n想象单颗二项树的情景，有$d=log_2n$，由于$n$减小，故$d\u0026gt;log_2n$。扩展到堆也可能成立。\n因此均摊操作复杂度取决于$d$的上界，后续会证明$d$的上界。思路：找到二项树对应的结点数最小的树，即斐波那契树的结点数目。\n减小键值 再回想一下减小键值的操作：\n减小键值对应着摘下结点（若堆序被破坏）。\n当已被标记的结点的子结点被摘下后，该结点应取消标记并也被摘下，递归地向父结点进行直至没有标记。\n根结点不能失去结点：对父结点为根结点的操作特殊处理。\n伪代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 DecreaseKey(x, k) { key(x) = k; if (heap order is violated) { p = x-\u0026gt;parent; if (p is root node) { Swap key between p and x; return; } Cut the subtree rooted at x, and insert it into the root list; Change the pointer to the min root node; while (p is marked) { Cut the subtree rooted at p, and insert it into the root list; Change the pointer to the min root node; Unmark p; p = p-\u0026gt;parent; } Mark p; } } 为了复杂度计算方便，暂时先不考虑x的父结点为根结点的情况。由伪代码可以得到，一次操作消耗的时间为$1+w,w=\\#while$。\n考察势函数$\\Phi=\\#tree+2\\#mark$，一次减小键值操作带来的势函数变化为：\n上升（静态）：$1+2=3$ 下降（动态）：$（-1+2）w=w$ 故一次操作消耗的时间为$1+decrease\\ in\\ \\Phi$。\n当x的父结点为根结点时也符合上式。\n插入 $\\Phi$上升$1$，下降$0$。\n一次操作消耗的时间为$1$。\n分析 考虑一段操作序列：$r$次插入，$s$次提取最小值，$t$次减小键值。\n总的运行时间最大为：$r+sd_{max}+t+total\\ decrease\\ in\\ \\Phi$。\n注意到：$(total\\ decrease\\ in\\ \\Phi) \\le (total\\ increase\\ in\\ \\Phi) = r+sd_{max}+3t$。\n因此总的运行时间最大为：$2r+2sd_{max}+4t$。\n因此插入的均摊复杂度为$O(1)$，减小键值的均摊复杂度为$O(1)$，提取最小值的均摊复杂度为$O(d_{max})$。\n$d_{max}$限界分析 $d_{max}$为$d$的上界，限界即确定$d_{max}$与堆结点数目$n$的关系。\n考虑一颗$B_k$树，则其度$d=log_2n$，若堆中有多颗$B$树，相当于$n$增加，则其中一颗树的度$d\u0026lt;log_2n$。因此为了确定$d$的上界，堆中树越少越好，即只有一颗。\n考虑一颗$B_k$树，其度$d=log_2n$，若从其上摘下结点（减小键值操作），对单颗树来说，相当于$n$减小，则$d\u0026gt;log_2n$，当$n$最小时，此时取得最大的$d$。也可以考虑为$n$不变时，这种构成堆的方式（即单颗树且丢失最多的结点）可使$d$最大，即取到$d_{max}$。\n于是我们开始寻找各个度对应的最少结点树，不妨记其为$F_k$，$k$为度数：\n回想二项树$B_{k+1}$由两颗$B_k$树构成：\n$F_{k+1}$树由$F_{k}$和$F_{k-1}$构成：\n尽管$|F_k|\u0026lt;|B_k|$，但不会小太多。$|F_k|\\ge1.618^k$。\n对于斐波那契数列： $$ f_k=f_{k-1}+f_{k-2},f_0=0,f_1=1 $$ 注意到$|F_k|=f_{k+2}$，因为$|F_0|=f_2=1, |F_1|=f_3=2，|F_{k}|=|F_{k-1}|+|F_{k-2}|$。\n由斐波那契通项性质$f_{k+2} \\ge \\phi^k, \\phi=\\frac{1+\\sqrt{5}}{2}=1.618\u0026hellip;$。\n考虑一个斐波那契堆含有$n$个结点，$T$为其中一颗树，其根结点度为$d$。\n则$n\\ge|T|\\ge|F_d|=f_{d+2}\\ge\\phi^d$。\n因此$d\\le log_{\\phi}n$。故$O(d_{max})=O(log_{\\phi}n)=O(logn)$。\n因此提取最小值的均摊复杂度为$O(logn)$。\n","date":"2023-11-15T20:43:01+08:00","image":"https://chengyuan-artist.github.io/posts/algo_heap/images/image-feature_hu5030604464604671321.png","permalink":"https://chengyuan-artist.github.io/posts/algo_heap/","title":"算法笔记|二叉堆，二项堆和斐波那契堆（原理篇）"},{"content":"朴东波算法课分治一节的算法作业及题解。\nQ1 两个升序数组的中位数 你有兴趣分析来自两个独立数据库的一些难以获取的数据。每个数据库包含n个数值，因此总共有2n个值，你可以假设没有两个值是相同的。你想确定这组2n个值的中位数，我们将在这里将其定义为第n个最小值。但是，你可以访问这些值的唯一方法是通过对数据库的查询。在单个查询中，你可以为两个数据库之一指定一个值k，所选数据库将返回它包含的第k个最小值。由于查询很昂贵，因此你希望使用尽可能少的查询来计算中位数。给出一个最多使用O（logn）查询找到中位数的算法。\n算法描述：记两个数据库中的数据分别构成集合$A$和$B$。\n取$A$中第$i$小的元素$a_i$，将$A$分成$A_L$ 和$A_R$两部分，其中\n$A_L= \\lbrace a\\mid a\\in A, a\u0026lt;=a_i \\rbrace$ ，$A_R= \\lbrace a\\mid a\\in A, a\u0026gt;a_i \\rbrace$。\n特别地，当$i=0$时，设$A_L=\\emptyset$，$A_R=A$。\n同样，取$B$中第$j$小的元素$b_j$，将$B$分成$B_L$ 和$B_R$两部分，其中\n$B_L= \\lbrace b\\mid b\\in B, b\u0026lt;=b_j \\rbrace$，$B_R= \\lbrace b \\mid b\\in B, b\u0026gt;b_j \\rbrace$。\n特别地，当$j=0$时，设$B_L=\\emptyset$，$B_R=B$。\n记$C_L=A_L\\cup B_L$，$C_R=A_R\\cup B_R$。\n当$|C_L|=|C_R|=n$ 且 $max(C_L) \u0026lt;= min(C_R)$时，题目所求的中位数即为$(max(C_L)+min(C_R))/2$。\n由$|C_L|=|C_R|=n$ 可得$i+j=n$，而$max(C_L)=max(a_{i},b_j)$，$min(C_R)=min(a_{i+1}, b_{j+1})$。算法只需要从$0$到$n$枚举$i$，当满足$max(a_{i},b_j)\u0026lt;=min(a_{i+1}, b_{j+1})$条件时即可得到中位数。\n采用二分法来枚举$i$。设$i_{min}=0$，$i_{max}=n$，令$i=(i_{min}+i_{max})/2$。\n若$a_i\u0026lt;=b_{j+1}$且$b_j\u0026lt;=a_{i+1}$，算法结束，返回中位数为$(max(a_{i},b_j)+min(a_{i+1}, b_{j+1}))/2$；\n若$a_i\u0026gt;=b_{j+1}$且$b_j\u0026lt;=a_{i+1}$，说明需要减小$i$，于是令$i_{max}=i-1$，继续二分$i$进行枚举；\n若$a_i\u0026lt;=b_{j+1}$且$b_j\u0026gt;=a_{i+1}$，说明需要减小$j$，即增大$i$，于是令$i_{min}=i+1$，继续二分。\n当$a_i\u0026gt;=b_{j+1}$时一定有$b_j\u0026lt;=a_{i+1}$，若当$a_i\u0026gt;=b_{j+1}$时$b_j\u0026gt;=a_{i+1}$，则有$a_i\u0026gt;=b_{j+1}\u0026gt;=b_{j}\u0026gt;=a_{i+1}$，与$a_{i}\u0026lt;=a_{i+1}$相矛盾。同理可证当$b_j\u0026gt;=a_{i+1}$时一定有$a_i\u0026lt;=b_{j+1}$，因此上述三种情况可以涵盖完毕。\n上述算法的伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 GetMedian(A, B, n) { left = 0, right = n; while(left \u0026lt;= right) { i = (left + right) / 2; j = n - i; if(i == 0) return (B[j] + A[i+1]) / 2; if(i == n) return (A[i] + B[j+1]) / 2; if(A[i] \u0026lt;= B[j+1] \u0026amp;\u0026amp; B[j] \u0026lt;= A[i+1]) return (max(A[i], B[j]) + min(B[j+1], A[i+1])) / 2; if(A[i] \u0026gt;= B[j+1]) { left = i - 1; continue; } if(B[j] \u0026gt;= A[i+1]) { right = i + 1; continue; } } } 其中将对数组A，B的下标访问操作视作对数据库的一次查询操作。\n可以看到，每轮循环最多对数据库进行4次查询操作（假设重复查询存在缓存）则有时间复杂度$T(n)=T(n/2)+4$，由主定理可得$T(n)=O(logn)$。\nQ2 平面最近点对 给定任意10个点，p1，p2，…，p10，在二维欧几里得平面上，请写一个算法来求最近的一对点之间的距离。\n（a）用蛮力算法来解决这个问题，分析你实现的蛮力算法的时间复杂度，并解释为什么算法的时间复杂度是$O(n^2)$，其中n是点数。\n（b）提出一种改进算法来解决这个问题，时间复杂度优于蛮力算法。描述算法的思想并分析其时间复杂度\n(a) 暴力算法：对每两个点计算距离，若距离小于当前最小值，则更新最小值。\n伪代码：\n1 2 3 4 5 6 7 8 9 10 minDist(P, n) { // P为点集，n为点的数量 min_d = INF; for(i = 0; i \u0026lt; n; ++i) { for(j = i + 1; j \u0026lt; n; ++j) { 计算P[i],P[j]两点的距离d; if(d \u0026lt; min_d) min_d = d; } } return min_d; } 对于计算两点间距离的操作，算法共进行$n(n-1)/2$次，因此算法的时间复杂度为$O(n^2)$。\n(b) 算法描述：\n设点集为$P$，首先将$P$中所有点按照以$x$坐标为第一关键字，$y$坐标为第二关键字从小到大进行排序。以中间点$p_m$的序号将点集分为两个集合$A$，$B$。对$A$和$B$分别调用本算法，得到点集$A$的结果$d_1$和点集$B$的结果$d_2$。\n令$d=min(d_1, d_2)$。设集合$C=\\lbrace p_i\\mid p_i\\in P, |p_i.x-p_m.x|\u0026lt;=d\\rbrace$，集合$C$中可能存在距离小于$d$且分别位于$A$和$B$的两点，因此求出集合$C$上的最短距离$d_c$，即可得到最短距离$d_{min}=min(d_c, d)。$\n对于集合$C$的任意一点$p_i$，设集合$D_i={p_j\\mid p_j\\in C, p_i.y\u0026lt;=p_j.y}$，求出$p_i$与$p_j$的距离并更新最短距离，即可求出点集$C$上的最短距离。\n将集合$C$按照$y$坐标由小到大排序，则集合$D_i$中的点为$p_i$的相邻几个点。可以设置集合$T=\\empty$，从大到小枚举$p_i$，并从大到小枚举$p_j\\in T$，枚举$p_j$过程中保证$p_j.y \u0026lt; p_i.y + d$，计算$p_i$与$p_j$间的距离并更新最小值，随后将$p_i$加入集合$T$，重复循环。可以看到在枚举过程中始终有$D_i \\subseteq T$，且枚举$p_j$的集合恰好等于$D_i$。该算法保证没有多余的循环出现。\n算法的复杂度取决于合并阶段求集合$C$上最短距离的时间复杂度，而该复杂度取决于集合$D_i$的规模大小，下面将通过证明$|D_i|$为常数从而证明这个操作是$O(n)$的。\n如图绿色阴影区域为集合$D_i$。对于右边每个小正方形，其对角线长度为$\\frac{d}{\\sqrt{2}}$，因此小正方形中最多含有一个点，因此集合$D_i$除位于最下方边界处的点$p_i$外最多存在7个点，由此，求集合$C$上最短距离的时间复杂度为$O(7n)=O(n)$。\n此外，由于该算法要求集合$C$按照纵坐标排序，我们可以要求子问题将点集按照纵坐标排序，父问题只需要合并子问题的排序结果即可，合并排序的时间复杂度也为$O(n)$。故合并操作总的时间复杂度为$O(n)$。\n当子问题规模足够小$(n \u0026lt;= 3)$，即可暴力求解最短距离并排序点集。\n算法的时间复杂度$T(n)=2T(\\frac{n}{2})+O(n)$，根据主定理可得$T(n)=O(nlogn)$。\n算法的伪代码如下：\n定义全局变量最短距离d，每次计算两点距离便更新一次d。使用缓冲区数组T来保存集合C。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 d = INF; minDist(P, left, right) { if(right - left + 1 \u0026lt;= 3) { for(i = left; i \u0026lt;= right; ++i) for(j = i + 1; j \u0026lt;= right; ++j) 计算P[i],P[j]两点的距离并更新最小值d; 以y为关键字排序点集P; return; } m = (left + right) / 2; minDist(P, left, m); minDist(P, m + 1, right); 以y为关键字归并左右两个集合的排序结果; 创建点集数组T; t_len = 0; for(i = right; i \u0026gt;= left; --i) { // 反向建立集合C if(abs(P[i].x - P[m].x) \u0026lt; d) { for(j = t_len - 1; j \u0026gt;= 0 \u0026amp;\u0026amp; P[j].y \u0026lt; P[i].y + d; --j) 计算P[i],P[j]两点的距离并更新最小值d; T[t_len++] = P[i]; } } } 以x为第一关键字，y为第二关键字排序点集P; minDist(P, 0, n - 1); Q3 快速次幂运算 给定一个整数n，其中100\u0026lt;n\u0026lt;10000，请设计一个高效算法计算$3^n$，时间复杂度不超过O（n）。\n（a）实现一个朴素数据口径计算$3^n$，并分析该朴素数据口径的时间复杂度。\n（b）提出一个改进算法计算$3^n$，时间复杂度不超过O（n）。描述算法的概念并分析其时间复杂度。\n(a) 将问题分割成n-1和1的子问题，即$f(n)=3*f(n-1)$，$f(1) = 3$。则递归或循环要进行n-1次，做n-1次乘法，时间复杂度为O(n)。\n(b) 均匀地分割问题：\n$$ f(n)= \\begin{cases} f(\\frac{n}{2})*f(\\frac{n}{2})\u0026amp; \\text{n为偶数} \\\\ f(\\frac{n-1}{2})*f(\\frac{n-1}{2})*3\u0026amp; \\text{n为奇数}\\end{cases}, f(1) = 3 $$\n伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 f(n) { if(n == 1) return 3; if(n % 2 == 0) { t = f(n / 2); return t * t; } if(n % 2 != 0) { t = f((n - 1) / 2); return 3 * t * t; } } 时间复杂度$T(n) = T(\\frac{n}{2})+c$，由主定理可得$T(n) = O(logn)$。\nQ4 反转二叉树 给定一棵二叉树T，请给出一个O（n）算法来反转二叉树。例如下面，反转左二叉树，我们得到右二叉树。\n算法描述：对于二叉树T，分别递归地调用本算法翻转左子树和右子树，随后交换左子树和右子树的索引。\n伪代码：\n1 2 3 4 5 invert(t) { if(t == null) return; invert(t-\u0026gt;left), invert(t-\u0026gt;right); swap(t-\u0026gt;left, t-\u0026gt;right); } 时间复杂度分析：若二叉树为完全均匀的满二叉树，则时间复杂度$T(n)=2T(\\frac{n}{2})+c$，由主定理可得$T(n)=O(n)$。对于一般情况，我们可以统计交换索引操作的次数。由伪代码可以看出，所有非空树结点都需要进行一次交换操作，由于存在n个树结点，因此操作数为n次，故时间复杂度为$O(n)$。\nQ5 越狱状态数 一个监狱有N个房间，每个囚犯一个，有M个宗教，每个囚犯都会遵循其中一个。如果相邻房间的囚犯是同一宗教的，可能会发生越狱。请给出一个O（n）算法，找出可以发生多少个状态的越狱。例如，有3个房间和2种宗教，那么将发生6种不同的状态的越狱。\n算法分析：\n记规模为n的问题解为E(n)。从题目的形式可以看出，如果知道了E(n)，E(n+1)将很容易地由E(n)推出。设想在n个牢房的最右端加入1间牢房，若前n间牢房已经满足越狱状态，则新加入牢房的犯人不论是何种信仰均不影响整体的越狱状态，对应$E(n)*m$种情况；若前n间牢房未满足越狱状态，此时对应前n间牢房的状态总数减去前n间牢房的越狱状态数，即$m^n-E(n)$，此时若想使整体达到越狱状态，第n+1间牢房就需要安排与第n间牢房信仰相同的犯人，因此该种情况下n+1牢房的越狱状态数与$(m^n-E(n))$一一对应。故 $$ E(n+1)=E(n)*m+m^n-E(n)=(m-1)*E(n)+m^n $$ 第一项为线性递归式，时间复杂度为线性的，注意到计算式中存在$m^n$，为了使整体的时间复杂度为线性的，可设$G(n)=m^{n}$，总体的表达式如下：\n$$E(n+1)=(m-1)*E(n)+G(n)，E(1) = 0$$\n$$G(n+1)=n*G(n)， G(1)=m$$\n算法的伪代码如下：(m为全局常数)\n1 2 3 4 5 6 7 Escape(n) { // return {E(n), G(n)} if(n == 1) return {0, m}; e, g = Escape(n - 1); g_next = n * g; e_next = (m - 1) * e + g; return {e_next, g_next}; } 每次递归共进行4次算术操作，共进行n-1次递归，故时间复杂度$T(n)=4(n-1)=O(n)$。\n","date":"2023-10-17T11:21:52+08:00","image":"https://chengyuan-artist.github.io/posts/divede_and_conquer_solution/images/maxresdefault_hu17828094125091697886.jpg","permalink":"https://chengyuan-artist.github.io/posts/divede_and_conquer_solution/","title":"分治题解"},{"content":"记录下go get 配置代理的坑\n今天在yay yay时，发现go build时某几个包总是get不下来，遂研究半天。\n发现go get 貌似不认ALL_PROXY环境变量，只认http_proxy和https_proxy, 特别是https_proxy要配好\u0026hellip;.\nOS第一节课搞了几十分钟。。。\ngit代理好像不用配，自动继承命令行代理。\n","date":"2021-10-11T11:23:57+08:00","permalink":"https://chengyuan-artist.github.io/posts/go_proxy/","title":"go get代理配置问题"},{"content":"记录Arch on wsl2的安装配置过程\nArchWsl下载安装 运行 Arch.exe 自动安装配置 一个Arch就装好了！ Arch基本配置 使用wsl -d \u0026lt;Arch name\u0026gt;进入Arch Bash Shell\n用户 设置root密码\n1 [root@PC-NAME user]# passwd 添加用户\n1 2 3 4 5 6 7 8 9 10 [root@PC-NAME]# EDITOR=nano visudo %wheel ALL=(ALL) ALL (设置 sudoers 文件 uncomment the above line) (保存 退出) [root@PC-NAME]# useradd -m -G wheel -s /bin/bash {username} (添加用户) [root@PC-NAME user]# passwd {username} (设置默认用户密码) 设置默认用户\n1 Arch.exe config --default-user {username} Pacman 初始化密钥环（keyring） (必须执行此步骤才可以使用 Pacman)\n1 2 3 [user@PC-NAME]$ sudo pacman-key --init [user@PC-NAME]$ sudo pacman-key --populate 修改pacman镜像源\n1 [user@PC-NAME]$ sudo vim /etc/pacman.d uncomment其中的China部分Server\n使用Pacman滚系统\n1 [user@PC-NAME]$ sudo pacman -Syu 代理 wsl2网络与windows网络ip是分开的，这里实现代理的方法是让wsl2走win下的代理\nClash客户端开启LAN\n将\n1 2 host_ip=$(cat /etc/resolv.conf |grep \u0026#34;nameserver\u0026#34; |cut -f 2 -d \u0026#34; \u0026#34;) export ALL_PROXY=\u0026#34;http://$host_ip:7890\u0026#34; 导入.bashrc或你正在使用的shell的配置文件（如.zshrc)\n1 source ~/.bashrc /etc/resolv.conf 保存了wsl的ip地址，由wsl每次运行时（猜测）自动生成\n基本配置到这里就做好了。\n","date":"2021-09-27T15:58:31+08:00","permalink":"https://chengyuan-artist.github.io/posts/archwsl/","title":"WSL2下优雅使用Arch"},{"content":"记录Hugo博客搭建的过程\n博客搭建 本文初步设定按照时间顺序，记录博客搭建的过程和踩过的坑，以及过程中学会的新姿势（\n技术栈选择 Hugo + GitHub Page\n搭博客这个想法年初就有了，git仓库也建好了，结果一直咕到现在。。。\n搭之前参考了一下周围同龄人大佬的技术栈，基本上分为Hexo和Hugo两类。逛了一下Hugo git仓库发现是拿go写的，果断选择Hugo（不得不说，go确实优美）。也是早早听说Github有免费托管网页的功能，因为相较其他部署方法（服务器Netlify等）感觉比较方便，所以选择了Github page。\n直到暑假NUS夏令营接触了一下云服务器，开学看了计网自顶而下的应用层部分，才知道HTTP协议，网络应用通信的基本原理有多简单。后悔没有早点了解，一直云里雾里。\nHugo安装 Windows 11\n一定要记得下载extend版本，非extend版本不支持Sass/SCSS扩展\nHugo并不提供installer安装版本，需要自行从git仓库下载对应版本安装包并解压。\n对于具体的安装，官方文档还贴心地给出了面对Technical Users和Less-technical Users的不同教程（，然而在Technical Users一栏在PowerShell中配置Path的方法是临时的。好奇PowerShell有没有像Linux .bashrc配置文件一样的东西，经过一番google发现确实有，Ps用一个叫profile的文件管理启动配置。于是马上按文档来创建。\n创建\n1 2 3 if (!(Test-Path -Path $PROFILE)) { New-Item -ItemType File -Path $PROFILE -Force } 编辑\n1 code $PROFILE 配置.ps1\n1 2 3 4 function InitPath { $env:Path += \u0026#34;;D:\\Coding\\Hugo\\bin\u0026#34; } InitPath 研究了一下，Ps的$env:path变量保存的初值是系统path+用户path，这条语句只会改变当前ps命令行的path值，不会影响系统变量。\n兴高采烈打开新Ps窗口，结果一大堆红字就跳了出来，貌似是没有脚本运行权限。又search一番发现，原来ps默认禁止配置脚本运行（晕。查阅有关文档，在Ps中Get-ExecutionPolicy的默认值为Restricted，不允许任何配置脚本文件运行，把此值改为RemoteSigned即可\n1 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned RemoteSigned默认为Windows server的权限属性\nRestricted默认为Windows client的权限属性（安全性考虑？普通用户真就不当人呗）\n至此，Hugo终于安装好了。\nArchLinux的安装只需要一行\n1 sudo pacman -Syu hugo 泪目了\n按照传统异能\n1 hugo version 显示\n1 hugo v0.88.1-5BC54738+extended windows/amd64 BuildDate=2021-09-04T09:39:19Z VendorInfo=gohugoio Hugo配置 Hugo使用config.toml文件来进行具体配置。除了一些通用配置外，剩下的配置基本都是根据你选定的主题xjb魔改就行了。例如：\n1 2 hugo new site blog cd blog 初始化git仓库\n1 git init 主题最好以submodule的形式添加，便于更新\n这里在themes文件夹下添加了LoveIt主题\n1 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 在配置文件config.toml中添加\n1 theme = \u0026#34;LoveIt\u0026#34; 剩下的配置按照LoveIt官方文档和themes/LoveIt目录下的exampleSite魔改即可。\n对于文章创建，Hugo使用Archetypes下的模板为你生成博客文件，不同主题都有自己不同的模板，使用命令\n1 hugo new posts/first_post.md 即可按照模板生成文档。\n或者，\n1 hugo new posts/first_post/index.md 这样便于将图片等资源放在文档同一目录下，便于索引。见Hugo文档Leaf Bundles\n另外，在查文档时还了解到用日期年月日来形成url索引文章的方式，如 9/23/21/hello.md。有空再去了解\n在配置网站的过程中，使用\n1 hugo server -D 可以实时查看网站的变化\n当调整满意后，使用\n1 hugo 生成静态网站，默认输出在public目录\n部署 一开始的想法是在Github建两个仓库，一个存网站Hugo源码，gitignorepublic文件更新；另一个以username.github.io 命名的仓库上传public的内容，逻辑看起来很清晰，对吧。但一开始直接犯蠢把Hugo源码发到username.github.io仓库了，结果Github page部署选择没法选public子文件，由于git姿势不够，遂把整个库删了\u0026hellip; 后来搞了两个仓库，又忘记ignorepublic，直接在public下新建git仓库，当时就感觉有点不对劲，因为这样的操作会导致public文件下的每个更新都会影响到整颗文件树，而本意是希望二者相对独立互不干扰（虽说加了gitignore当前情境下就没问题了，但毕竟是个一般性问题）。参考了这篇博客，发现git还有git worktree add操作，就是为了解决上述问题，新姿势get。\n这篇博客中提出了两种部署方法\n将hugo输出文件的默认文件夹名称改为docs\n只需要在config.toml中添加\n1 publishDir = docs 即可\n随后可以直接修改GitHub page部署docs下的网页。\n在public文件夹下建立独立分支\n配置GitHub page部署该独立分支的内容\n代码如下（示例）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //忽略public子目录 echo \u0026#34;public\u0026#34; \u0026gt;\u0026gt; .gitignore //初始化publish branch git checkout --orphan publish git reset --hard git commit --allow-empty -m \u0026#34;init publish branch\u0026#34; git push origin publish git checkout main // 部署 rm -rf public mkdir public rm -rf .git/worktrees/public/ // 在public下建立publish独立分支pulish // index reset 至远端 publish git worktree add -B publish public origin/publish hugo cd public git add --all git commit -m \u0026#34;some words\u0026#34; git push origin publish 这个方法的好处是可以将源文档和生成的网页文档的版本历史分开控制\n有关git worktree 相关知识，下篇博客总结一下（咕咕咕\n发现Netlify不仅有CDN服务器，还支持git仓库自动部署，直接run去Netlify了 (逃)\n","date":"2021-09-23T23:02:40+08:00","permalink":"https://chengyuan-artist.github.io/posts/blog_creation/","title":"Hugo博客搭建"},{"content":"Hello World! This is the first blog. It has 3 points:\nsimple clear nice 中文测试\n","date":"2021-09-20T16:36:52+08:00","permalink":"https://chengyuan-artist.github.io/posts/hello_world/","title":"Hello World"}]