<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content><title>算法笔记|二叉堆，二项堆和斐波那契堆（原理篇）</title>
<link rel=canonical href=https://chengyuan-artist.github.io/posts/algo_heap/><link rel=stylesheet href=/scss/style.min.80c03690600abd6147eeb7eaffb9a9d6e783f91621b1cf50638f7a12a3db8427.css><meta property='og:title' content='算法笔记|二叉堆，二项堆和斐波那契堆（原理篇）'><meta property='og:description' content><meta property='og:url' content='https://chengyuan-artist.github.io/posts/algo_heap/'><meta property='og:site_name' content='麦茶小站'><meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:tag' content='Algorithm'><meta property='article:published_time' content='2023-11-15T20:43:01+08:00'><meta property='article:modified_time' content='2023-11-22T14:03:16+08:00'><meta property='og:image' content='https://chengyuan-artist.github.io/posts/algo_heap/images/image-feature.png'><meta name=twitter:title content="算法笔记|二叉堆，二项堆和斐波那契堆（原理篇）"><meta name=twitter:description content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://chengyuan-artist.github.io/posts/algo_heap/images/image-feature.png'></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/zcy_hu12942041102693417476.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>麦茶小站</a></h1><h2 class=site-description>咕咕古</h2></div></header><ol class=social-menu><li><a href=https://github.com/Chengyuan-artist target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=/index.xml target=_blank title=rss rel=me><svg class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>友链</span></a></li><div class=menu-bottom-section><li id=i18n-switch><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://chengyuan-artist.github.io/ selected>中文</option></select></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#优先队列>优先队列</a><ol><li><a href=#动机>动机</a></li><li><a href=#操作定义>操作定义</a></li><li><a href=#应用举例>应用举例</a></li></ol></li><li><a href=#数组链表实现>数组/链表实现</a><ol><li><a href=#无序链表实现>无序链表实现</a></li><li><a href=#有序链表实现>有序链表实现</a></li><li><a href=#问题>问题</a></li></ol></li><li><a href=#二叉堆>二叉堆</a><ol><li><a href=#问题-1>问题</a></li></ol></li><li><a href=#二项式堆>二项式堆</a><ol><li><a href=#二项树>二项树</a></li><li><a href=#二项堆>二项堆</a></li><li><a href=#均摊分析>均摊分析</a><ol><li><a href=#插入>插入</a></li><li><a href=#提取最小值>提取最小值</a></li><li><a href=#分析>分析</a></li></ol></li><li><a href=#问题-2>问题</a></li></ol></li><li><a href=#斐波那契堆>斐波那契堆</a><ol><li><a href=#均摊分析-1>均摊分析</a><ol><li><a href=#提取最小值-1>提取最小值</a></li><li><a href=#减小键值>减小键值</a></li><li><a href=#插入-1>插入</a></li><li><a href=#分析-1>分析</a></li><li><a href=#d_max限界分析>$d_{max}$限界分析</a></li></ol></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/posts/algo_heap/><img src=/posts/algo_heap/images/image-feature_hu4450910162479030592.png srcset="/posts/algo_heap/images/image-feature_hu4450910162479030592.png 800w, /posts/algo_heap/images/image-feature_hu16885018092518194493.png 1600w" width=800 height=352 loading=lazy alt="Featured image of post 算法笔记|二叉堆，二项堆和斐波那契堆（原理篇）"></a></div><div class=article-details><header class=article-category><a href=/categories/algorithm/ style=background-color:#99f;color:#fff>Algorithm</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/posts/algo_heap/>算法笔记|二叉堆，二项堆和斐波那契堆（原理篇）</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Nov 15, 2023</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>5655 字 (阅读时长: 12 分钟)</time></div></footer></div></header><section class=article-content><h2 id=优先队列>优先队列</h2><h3 id=动机>动机</h3><p>某些情况下，我们需要频繁地<strong>动态</strong>地取出一个集合S中的最小元素/最大元素。</p><p>这里<strong>动态</strong>指我们需要在集合S上执行插入/删除/更改键值操作。</p><p>问题在于如何组织数据结构使这些操作更高效。</p><h3 id=操作定义>操作定义</h3><p>以最小优先队列为例：</p><div class=table-wrapper><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>MakeHeap()</td><td>建立一个堆H</td></tr><tr><td>Insert(H, x)</td><td>在堆H中插入元素x</td></tr><tr><td>ExtractMin(H)</td><td>提取堆H中的最小元素</td></tr><tr><td>DecreaseKey(H, x, k)</td><td>减小堆中元素x的键值为k</td></tr><tr><td>Union(H1 , H2 )</td><td>返回一个新堆包含H1和H2的所有元素，销毁输入堆</td></tr></tbody></table></div><h3 id=应用举例>应用举例</h3><ul><li>Dijkstra单源最短路算法：需要<code>ExtractMin</code></li><li>Prim最小生成树算法：需要<code>ExtractMin</code>与<code>DecreaseKey</code></li><li>Why we need Union?</li></ul><h2 id=数组链表实现>数组/链表实现</h2><p>我们可以用数组或链表快速实现一个简单版本的优先队列。</p><p>由于本篇偏向理论分析，因此更在意数据结构的<strong>逻辑结构</strong>而非物理结构。对以下两种实现方式而言，可以认为数组的逻辑结构和链表相同（实际上二者复杂度分析也相同），因此都用链表代替。</p><h3 id=无序链表实现>无序链表实现</h3><img src=./images/image-20231115215858165.png alt=image-20231115215858165 style=zoom:50%><p>每次都在首部插入新元素；提取最小值时，遍历链表找到最小值并更改链表指针将其从链表中删除。</p><p>（数组版本）每次在尾部插入新元素；提取最小值时，遍历数组找到最小值并将其与尾部元素交换位置，减小长度计数。</p><p>复杂度：</p><ul><li>插入操作：$O(1)$</li><li>提取最小值：$O(n)$</li></ul><h3 id=有序链表实现>有序链表实现</h3><img src=./images/image-20231115220444807.png alt=image-20231115220444807 style=zoom:50%><p>插入新元素时，遍历链表至第一个大于其的元素位置处，在此之前插入；提取最小值直接返回首部，并将其删除（更改头指针）。</p><p>（数组版本）倒序维护数组大小，插入新元素时，遍历链表至第一个小于其的元素位置处，在此之前插入，后续元素后移；提取最小值时直接返回尾部，并将其删除（减小长度计数）。</p><p>复杂度：</p><ul><li>插入操作：$O(n)$</li><li>提取最小值：$O(1)$</li></ul><h3 id=问题>问题</h3><p>是否存在使得插入和提取最小值时间复杂度更均衡/更优的数据结构？</p><h2 id=二叉堆>二叉堆</h2><p>观察有序链表实现，插入操作实际上每次都在进行插入排序以维持整个链表的有序，然而这属于工作过头了，我们只需要维护一个最小值。</p><ul><li>有序链表的每个指针指向的元素都大于等于自身，数据结构限制过于严格，因此需要<strong>放松限制</strong>。</li><li>但限制不能<strong>过分放松</strong>，否则就会像无序链表那样，元素间没有任何限制，导致提取操作复杂度上升。</li></ul><p>二叉堆：</p><ul><li>逻辑结构：一颗二叉树，且父结点小于子结点。所有结点除最后一层外按照完全二叉树排列。</li></ul><img src=images/image-20231115224930406.png alt=image-20231115224930406 style=zoom:67%><ul><li><p>物理结构：为了便于随机读取以及减少指针开销。结点以完全二叉树编号为下标放入数组中。</p><img src=images/image-20231115225848350.png alt=image-20231115225848350 style=zoom:67%><p>因此对结点$i$ ，左子结点下标为$2i$，右子结点下标为$2(i + 1)$，父结点下标为$ (i-1)/2$（向下取整）。下标越界时，表示结点不存在。</p></li></ul><p>操作：</p><ul><li><p>插入：将新元素置于二叉堆尾部，依次向上调整，使得最小堆性质（父结点小于子结点）保持。由于二叉堆高为$log_2n$（$n$为元素个数），因此时间复杂度为$O(logn)$。</p></li><li><p>提取最小值：将堆顶元素与堆尾元素交换，减小堆数组长度计数，从根结点开始依次向下调整，使得最小堆性质保持。时间复杂度为$O(logn)$。</p></li><li><p><code>DecreaseKey(x, k)</code>：将下标<code>x</code>处元素值降低为<code>k</code>。从该元素开始依次向上调整。时间复杂度为$O(logn)$。</p></li><li><p>建堆：</p><ul><li><p>通过建空堆依次入堆。时间复杂度$O(nlogn)$。</p></li><li><p>通过"遍历堆化"实现。将所有元素原封不动地入堆，随后调整堆结构。</p><ul><li><p>方法：按照完全二叉树编号从尾结点开始向根结点依次调用“向下调整”。</p></li><li><p>时间复杂度：将堆补充为完全二叉树，不影响复杂度计算。设层高为$d = log_2n$。从上到下依次为第0&mldr;d层。对第i层，操作总次数为$2^i*(d-i)$​。因此总操作数
$$
T(n)=2^0d+2^1(d-1)+2^2(d-2)&mldr;+2^{d-1}
$$</p><p>$$
2T(n)=2^1d+2^2(d-1)+&mldr;+2^{d}
$$</p><p>故
$$
T(n)=2^1+2^2+&mldr;+2^d -d=2\frac{1-2^d}{1-2}-d=2^{d+1}-d-2=O(2^{d+1})=O(n)
$$</p></li></ul></li></ul></li><li><p>合并：将两个堆的数据组成一个堆，再遍历堆化。$O(n)$。</p></li></ul><p>至此，我们得到了插入，提取，改键均为$O(logn)$，且合并为$O(n)$的堆。实现简单且复杂度不错。</p><h3 id=问题-1>问题</h3><p>如果想进一步降低<strong>合并</strong>的复杂度，该怎样调整数据结构？</p><h2 id=二项式堆>二项式堆</h2><p>观察二叉堆的逻辑结构，我们发现只允许<strong>一棵树</strong>存在这一限制。因此在两个堆合并时，需要拆散两颗树合并为一颗。如果允许多棵树存在，逻辑结构不是一棵树而是<strong>森林</strong>。合并时无需破坏原有堆的结构。</p><ul><li>放松限制：一棵树 -> 允许森林</li><li>不要过分放松：<strong>同类型</strong>的树只存在一颗。</li></ul><p>综上，既然允许多棵树存在，插入操作就变成了<strong>合并</strong>操作，即合并一颗只含根结点的树，直接将其插入森林中即可；由于同类型的树只能有一颗，我们需要合并<strong>同类型</strong>的树，合并后的树也应该属于<strong>某个类型</strong>。</p><h3 id=二项树>二项树</h3><p>定义：$B_k$为二项式树，定义$k$为$B_k$的度数。</p><ul><li>$B_0$只含有一个结点</li><li>两个$B_k$可以合并为$B_{k+1}$</li></ul><blockquote><p>这里合并操作指将$B_k$作为另一$B_k$的根结点的儿子插入。</p></blockquote><p>这样的定义使二项树有一些有趣的性质：</p><ul><li>$B_k$树层高为$k$</li><li>$B_{k}$树的每个子结点分别为$B_0,B_1,&mldr;,B_{k-1}$ （$B_k$树的第$i$个子结点的度为$i-1$）</li><li>$B_k$树的每层结点个数正好是$k$的二项式系数（$(a+b)^k$）（命名来源）</li><li>$|B_k|=2^k$</li></ul><h3 id=二项堆>二项堆</h3><p>定义：二项堆为二项树组成的森林</p><ul><li>其中每个度数的二项树只有一颗</li><li>对于二项堆中的每颗二项树，满足最小堆性质</li></ul><p>由此，当二项堆里有相同类型的二项树需要合并时，取根结点最小的树的根结点作为父结点，将另一棵树作为其儿子插入。</p><p>二叉堆二项树根结点用双向链表连接，指针指向最小的根结点。</p><p>二项堆也有一些有趣的性质：</p><ul><li>对于规模为$n$的二项堆，其二项树的组合是<strong>确定</strong>的。二项堆含有$B_i$当且仅当$b_i=1$，其中$(b_kb_{k-1}&mldr;b_0)_2=n$。</li><li>二项堆最多含有$log_2n$（向下取整）颗二项树</li><li>二项堆的层高不超过$log_2n$（向下取整）</li></ul><p>操作：</p><ul><li>插入：合并一颗$B_0$树。最好情况下$O(1)$，最坏情况下$O(logn)$，均摊复杂度为$O(1)$。这是什么？别急</li><li>提取最小值：将最小根结点取出，将该二项树拆为其所有子树，合并相同类型的二项树。$O(logn)$。</li><li>合并：复杂度$O(logn)$，均摊复杂度$O(1)$。</li><li>减小键值：在某颗二项树上向上调整。$O(logn)$。</li></ul><h3 id=均摊分析>均摊分析</h3><p>为什么要均摊分析？在分析插入/合并/提取最小值时，我们总考虑工作量的上限，即最坏情况，推出复杂度均为$O(logn)$。但是这三个操作复杂度在时间上具有继承性，如果做了一次工作量较大的操作，随后许多次操作都只需要很小的工作量。这种情况下可以引入<strong>势能分析</strong>。</p><h4 id=插入>插入</h4><p>伪代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Insert(x) {
</span></span><span class=line><span class=cl>  Creat a B0 tree for x;
</span></span><span class=line><span class=cl>  Change the pointer to the min root;
</span></span><span class=line><span class=cl>    while (there are two Bk tree for some k) {
</span></span><span class=line><span class=cl>      Link them into one Bk+1 tree;
</span></span><span class=line><span class=cl>      Change the pointer to the min root;
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>一次插入操作需要消耗$1+w$时间，$w=\#while$ 是<code>while</code>语句执行的数量，$\#$表示<code>number of</code>。</p><p>引入势函数$\Phi=\#tree$，即二叉堆中树的数量。当进行一次插入操作后，势函数可以分为上升的部分和下降的部分。</p><ul><li>上升：$1$</li><li>下降：$w$，即树减少的数量</li></ul><p>因此一次插入操作需要$1+decrease\ in\ \Phi$。而由于$\Phi>=0$，故$all\ decrease\ in\ \Phi &lt;= all\ increase\ in\ \Phi$。这为我们统计一系列操作提供了方便。</p><p>可以看到，当分析合并时，伪代码与插入只有第二行的区别，一次合并操作需要的时间也是$1+decrease\ in\ \Phi$。</p><h4 id=提取最小值>提取最小值</h4><p>伪代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ExtractMin(H) {
</span></span><span class=line><span class=cl>  Remove the min node and insert its children to the root list;
</span></span><span class=line><span class=cl>  Change the pointer to the min node;
</span></span><span class=line><span class=cl>  while (there are two Bk tree for some k) {
</span></span><span class=line><span class=cl>    Link them into one Bk+1 tree;
</span></span><span class=line><span class=cl>    Change the pointer to the min root;
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>一次操作需要消耗$d+w$，$w=\#while$，$d$为去除根结点的树的度（也是其子树数量）。</p><p>我们用同样的势函数$\Phi=\#tree$。进行一次操作，势函数既有上升的部分也有下降的部分。</p><ul><li>上升：$d$</li><li>下降：$w$</li></ul><p>因此一次操作需要$d+decrease\ in\ \Phi$。其中$d&lt;=log_2n$。</p><h4 id=分析>分析</h4><p>若对一个二叉堆做了$a$次插入操作和$b$次提取最小值操作，总消耗的时间</p><p>$$
\begin{align*}
T(a,b)&= a(1+decrease\ in\ \Phi)+b(d+decrease\ in\ \Phi) \\\
&\le a(1+increase\ in\ \Phi)+b(d+increase\ in\ \Phi) \\\
&=a+bd+all\ increase\ in\ \Phi \\\
&=a+bd+a+bd=2a+2bd \\\
&\le 2a+2blogn
\end{align*}
$$
由于$n$与$m$无关，因此插入操作的均摊复杂度为$O(\frac{T(a)}{a})=O(1)$，提取最小值的操作的均摊复杂度为$O(\frac{T(b)}{b})=O(logn)$。合并操作均摊复杂度与插入操作相同，为$O(1)$。</p><h3 id=问题-2>问题</h3><p>对比二叉堆，我们成功地将合并操作的复杂度降低为$O(1)$（均摊）。如果进一步考虑，如何降低<strong>减小键值</strong>的复杂度呢？</p><h2 id=斐波那契堆>斐波那契堆</h2><p>对于减小键值操作，无论是二叉堆还是二项堆，都避免不了对堆进行调整的操作。为了降低复杂度，能否进行操作后，不进行或推迟调整操作？</p><p>斐波那契堆在二项堆的基础上：</p><ul><li><p><strong>放松限制</strong>，允许同类型的二项树共存；同时在减小键值操作后，并不调整堆而是直接将该结点及其子树摘下放入根结点列表中，同时给该结点的父结点打上标记，已表明该父节点“失去”过一个结点。（1）</p></li><li><p>注意到该限制不是<strong>完全放松</strong>的，对每颗二项树而言，非根结点最多失去一个结点。（2）</p></li></ul><blockquote><p>“摘下”操作相当于取消了原来的堆调整过程，将其推迟到堆做合并时。减小键值对应着摘下结点。</p><p>当已被标记的结点的子结点被摘下后，该结点应取消标记并也被摘下，递归地向父结点进行直至没有标记。</p><p>根结点不允许失去结点 -> 便于统计树的度数 。</p></blockquote><p>注意到由于条件（1）的存在，插入和合并都只需向根结点列表中添加新的树即可。但堆总要做出调整，何时？</p><p>答案是不得不调整时，即<strong>提取最小值</strong>后，此时无论如何都要进行合并操作了，否则根结点列表数量将膨胀。</p><p>合并操作是合并<strong>相同度数</strong>的树。树的度数等于根结点的子结点数目。</p><p>操作：</p><ul><li>插入：合并一颗$B_0$树。复杂度$O(1)$。</li><li>提取最小值：将最小根结点取出，将拆为其所有子树并插入根结点列表。最坏&均摊$O(logn)$。为什么？</li><li>合并：复杂度$O(1)$。</li><li>减小键值：均摊复杂度$O(1)$。</li></ul><h3 id=均摊分析-1>均摊分析</h3><h4 id=提取最小值-1>提取最小值</h4><p>伪代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ExtractMin() {
</span></span><span class=line><span class=cl>  Remove the min node and insert its children to the root list;
</span></span><span class=line><span class=cl>  Change the pointer to the min node;
</span></span><span class=line><span class=cl>  while (there are two roots u and v of the same degree) {
</span></span><span class=line><span class=cl>	  Consolidate the two trees together;
</span></span><span class=line><span class=cl>	  Change the pointer to the min root;
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>与二叉堆的操作相同，但这里我们使用新的势函数$\Phi=\#tree+2\#mark$，$\#mark$为被标记的非根结点数量。 why?</p><p>一次提取最小值操作带来的势函数变化为：</p><ul><li>上升（静态）：$d$（移除结点的度）</li><li>下降（动态）：$w$</li></ul><p>一次操作需要$d+decrease\ in\ \Phi$，$d$为根结点的度。</p><blockquote><p>注意到由于树会被摘下结点，因此$d$有可能大于$log_2n$。</p><p>想象单颗二项树的情景，有$d=log_2n$，由于$n$减小，故$d>log_2n$。扩展到堆也可能成立。</p><p>因此均摊操作复杂度取决于$d$的上界，后续会证明$d$的上界。思路：找到二项树对应的结点数最小的树，即斐波那契树的结点数目。</p></blockquote><h4 id=减小键值>减小键值</h4><p>再回想一下减小键值的操作：</p><blockquote><p>减小键值对应着摘下结点（若堆序被破坏）。</p><p>当已被标记的结点的子结点被摘下后，该结点应取消标记并也被摘下，递归地向父结点进行直至没有标记。</p><p>根结点不能失去结点：对父结点为根结点的操作特殊处理。</p></blockquote><p>伪代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>DecreaseKey(x, k) {
</span></span><span class=line><span class=cl>  key(x) = k;
</span></span><span class=line><span class=cl>  if (heap order is violated) {
</span></span><span class=line><span class=cl>    p = x-&gt;parent;
</span></span><span class=line><span class=cl>    if (p is root node) {
</span></span><span class=line><span class=cl>      Swap key between p and x;
</span></span><span class=line><span class=cl>      return;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    Cut the subtree rooted at x, and insert it into the root list;
</span></span><span class=line><span class=cl>    Change the pointer to the min root node; 
</span></span><span class=line><span class=cl>    while (p is marked) {
</span></span><span class=line><span class=cl>      Cut the subtree rooted at p, and insert it into the root list;
</span></span><span class=line><span class=cl>      Change the pointer to the min root node;
</span></span><span class=line><span class=cl>      Unmark p;
</span></span><span class=line><span class=cl>      p = p-&gt;parent;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    Mark p;
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>为了复杂度计算方便，暂时先不考虑<code>x</code>的父结点为根结点的情况。由伪代码可以得到，一次操作消耗的时间为$1+w,w=\#while$。</p><p>考察势函数$\Phi=\#tree+2\#mark$，一次减小键值操作带来的势函数变化为：</p><ul><li>上升（静态）：$1+2=3$</li><li>下降（动态）：$（-1+2）w=w$</li></ul><p>故一次操作消耗的时间为$1+decrease\ in\ \Phi$。</p><p>当<code>x</code>的父结点为根结点时也符合上式。</p><h4 id=插入-1>插入</h4><p>$\Phi$上升$1$，下降$0$。</p><p>一次操作消耗的时间为$1$。</p><h4 id=分析-1>分析</h4><p>考虑一段操作序列：$r$次插入，$s$次提取最小值，$t$次减小键值。</p><p>总的运行时间最大为：$r+sd_{max}+t+total\ decrease\ in\ \Phi$。</p><p>注意到：$(total\ decrease\ in\ \Phi) \le (total\ increase\ in\ \Phi) = r+sd_{max}+3t$。</p><p>因此总的运行时间最大为：$2r+2sd_{max}+4t$。</p><p>因此插入的均摊复杂度为$O(1)$，减小键值的均摊复杂度为$O(1)$，提取最小值的均摊复杂度为$O(d_{max})$。</p><h4 id=d_max限界分析>$d_{max}$限界分析</h4><p>$d_{max}$为$d$的上界，限界即确定$d_{max}$与堆结点数目$n$的关系。</p><p>考虑一颗$B_k$树，则其度$d=log_2n$，若堆中有多颗$B$树，相当于$n$增加，则其中一颗树的度$d&lt;log_2n$。因此为了确定$d$的上界，堆中树越少越好，即只有一颗。</p><p>考虑一颗$B_k$树，其度$d=log_2n$，若从其上摘下结点（减小键值操作），对单颗树来说，相当于$n$减小，则$d>log_2n$，当$n$最小时，此时取得最大的$d$。也可以考虑为$n$不变时，这种构成堆的方式（即单颗树且丢失最多的结点）可使$d$最大，即取到$d_{max}$。</p><p>于是我们开始寻找各个度对应的最少结点树，不妨记其为$F_k$，$k$为度数：</p><img src=images/image-20231122124352469.png alt=image-20231122124352469 style=zoom:50%>
<img src=images/image-20231122124411709.png alt=image-20231122124411709 style=zoom:50%>
<img src=images/image-20231122124424160.png alt=image-20231122124424160 style=zoom:50%>
<img src=images/image-20231122124451912.png alt=image-20231122124451912 style=zoom:50%>
<img src=images/image-20231122124632445.png alt=image-20231122124632445 style=zoom:50%><p>回想二项树$B_{k+1}$由两颗$B_k$树构成：</p><img src=images/image-20231122124742938.png alt=image-20231122124742938 style=zoom:50%><p>$F_{k+1}$树由$F_{k}$和$F_{k-1}$构成：</p><img src=images/image-20231122125017065.png alt=image-20231122125017065 style=zoom:50%><p>尽管$|F_k|&lt;|B_k|$，但不会小太多。$|F_k|\ge1.618^k$。</p><p>对于斐波那契数列：
$$
f_k=f_{k-1}+f_{k-2},f_0=0,f_1=1
$$
注意到$|F_k|=f_{k+2}$，因为$|F_0|=f_2=1, |F_1|=f_3=2，|F_{k}|=|F_{k-1}|+|F_{k-2}|$。</p><p>由斐波那契通项性质$f_{k+2} \ge \phi^k, \phi=\frac{1+\sqrt{5}}{2}=1.618&mldr;$。</p><p>考虑一个斐波那契堆含有$n$个结点，$T$为其中一颗树，其根结点度为$d$。</p><p>则$n\ge|T|\ge|F_d|=f_{d+2}\ge\phi^d$。</p><p>因此$d\le log_{\phi}n$。故$O(d_{max})=O(log_{\phi}n)=O(logn)$。</p><p>因此提取最小值的均摊复杂度为$O(logn)$。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/algorithm/>Algorithm</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>最后更新于 Nov 22, 2023 14:03 CST</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/posts/divede_and_conquer_solution/><div class=article-image><img src=/posts/divede_and_conquer_solution/images/maxresdefault.2f81ee36e07a873a150cb8bee1a5d7c3_hu13145151434986233465.jpg width=250 height=150 loading=lazy alt="Featured image of post 分治题解" data-hash="md5-L4HuNuB6hzoVDLi+4aXXww=="></div><div class=article-details><h2 class=article-title>分治题解</h2></div></a></article></div></div></aside><script src=//cdn.jsdelivr.net/npm/twikoo@1.6.21/dist/twikoo.all.min.js></script><div id=tcomment></div><style>.twikoo{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}:root[data-scheme=dark]{--twikoo-body-text-color-main:rgba(255, 255, 255, 0.9);--twikoo-body-text-color:rgba(255, 255, 255, 0.7)}.twikoo .el-input-group__prepend,.twikoo .tk-action-icon,.twikoo .tk-submit-action-icon,.twikoo .tk-time,.twikoo .tk-comments-no,.twikoo .tk-comments-count{color:var(--twikoo-body-text-color)}.twikoo .el-input__inner,.twikoo .el-textarea__inner,.twikoo .tk-preview-container,.twikoo .tk-content,.twikoo .tk-nick,.twikoo .tk-send{color:var(--twikoo-body-text-color-main)}.twikoo .el-button{color:var(--twikoo-body-text-color)!important}.twikoo .el-input__count{color:var(--twikoo-body-text-color)!important}.OwO .OwO-body{background-color:var(--body-background)!important;color:var(--body-text-color)!important}</style><script>twikoo.init({envId:"https://scintillating-dragon-68e1aa.netlify.app/.netlify/functions/twikoo",el:"#tcomment"})</script><footer class=site-footer><section class=copyright>&copy;
2021 -
2024 麦茶</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.21.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300&family=Noto+Serif+SC:wght@400&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><style>:root{--zh-font-family:"Noto Serif SC", "PingFang SC", "Hiragino Sans GB", "Droid Sans Fallback", "Microsoft YaHei";--article-font-family:Verdana, "Noto Serif SC", var(--base-font-family)}</style></body></html>