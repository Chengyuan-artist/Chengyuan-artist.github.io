<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content><title>分治题解</title>
<link rel=canonical href=https://chengyuan-artist.github.io/posts/divede_and_conquer_solution/><link rel=stylesheet href=/scss/style.min.80c03690600abd6147eeb7eaffb9a9d6e783f91621b1cf50638f7a12a3db8427.css><meta property='og:title' content='分治题解'><meta property='og:description' content><meta property='og:url' content='https://chengyuan-artist.github.io/posts/divede_and_conquer_solution/'><meta property='og:site_name' content='麦茶小站'><meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:tag' content='Algorithm'><meta property='article:published_time' content='2023-10-17T11:21:52+08:00'><meta property='article:modified_time' content='2023-10-17T11:21:52+08:00'><meta property='og:image' content='https://chengyuan-artist.github.io/posts/divede_and_conquer_solution/images/maxresdefault.jpg'><meta name=twitter:title content="分治题解"><meta name=twitter:description content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://chengyuan-artist.github.io/posts/divede_and_conquer_solution/images/maxresdefault.jpg'></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/zcy_hu12942041102693417476.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>麦茶小站</a></h1><h2 class=site-description>咕咕古</h2></div></header><ol class=social-menu><li><a href=https://github.com/Chengyuan-artist target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=/index.xml target=_blank title=rss rel=me><svg class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>友链</span></a></li><div class=menu-bottom-section><li id=i18n-switch><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://chengyuan-artist.github.io/ selected>中文</option></select></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#q1-两个升序数组的中位数>Q1 两个升序数组的中位数</a></li><li><a href=#q2-平面最近点对>Q2 平面最近点对</a><ol><li><a href=#a>(a)</a></li><li><a href=#b>(b)</a></li></ol></li><li><a href=#q3-快速次幂运算>Q3 快速次幂运算</a><ol><li><a href=#a-1>(a)</a></li><li><a href=#b-1>(b)</a></li></ol></li><li><a href=#q4-反转二叉树>Q4 反转二叉树</a></li><li><a href=#q5-越狱状态数>Q5 越狱状态数</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/posts/divede_and_conquer_solution/><img src=/posts/divede_and_conquer_solution/images/maxresdefault_hu2608924653077798863.jpg srcset="/posts/divede_and_conquer_solution/images/maxresdefault_hu2608924653077798863.jpg 800w, /posts/divede_and_conquer_solution/images/maxresdefault_hu17306791599518927624.jpg 1600w" width=800 height=450 loading=lazy alt="Featured image of post 分治题解"></a></div><div class=article-details><header class=article-category><a href=/categories/algorithm/ style=background-color:#99f;color:#fff>Algorithm</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/posts/divede_and_conquer_solution/>分治题解</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Oct 17, 2023</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>4412 字 (阅读时长: 9 分钟)</time></div></footer></div></header><section class=article-content><p>朴东波算法课分治一节的算法作业及题解。</p><h2 id=q1-两个升序数组的中位数>Q1 两个升序数组的中位数</h2><blockquote><p>你有兴趣分析来自两个独立数据库的一些难以获取的数据。每个数据库包含n个数值，因此总共有2n个值，你可以假设没有两个值是相同的。你想确定这组2n个值的中位数，我们将在这里将其定义为第n个最小值。但是，你可以访问这些值的唯一方法是通过对数据库的查询。在单个查询中，你可以为两个数据库之一指定一个值k，所选数据库将返回它包含的第k个最小值。由于查询很昂贵，因此你希望使用尽可能少的查询来计算中位数。给出一个最多使用O（logn）查询找到中位数的算法。</p></blockquote><p>算法描述：记两个数据库中的数据分别构成集合$A$和$B$。</p><p>取$A$中第$i$小的元素$a_i$，将$A$分成$A_L$ 和$A_R$两部分，其中</p><p>$A_L= \lbrace a\mid a\in A, a&lt;=a_i \rbrace$ ，$A_R= \lbrace a\mid a\in A, a>a_i \rbrace$。</p><p>特别地，当$i=0$时，设$A_L=\emptyset$，$A_R=A$。</p><p>同样，取$B$中第$j$小的元素$b_j$，将$B$分成$B_L$ 和$B_R$两部分，其中</p><p>$B_L= \lbrace b\mid b\in B, b&lt;=b_j \rbrace$，$B_R= \lbrace b \mid b\in B, b>b_j \rbrace$。</p><p>特别地，当$j=0$时，设$B_L=\emptyset$，$B_R=B$。</p><p>记$C_L=A_L\cup B_L$，$C_R=A_R\cup B_R$。</p><p>当$|C_L|=|C_R|=n$ 且 $max(C_L) &lt;= min(C_R)$时，题目所求的中位数即为$(max(C_L)+min(C_R))/2$。</p><p>由$|C_L|=|C_R|=n$ 可得$i+j=n$，而$max(C_L)=max(a_{i},b_j)$，$min(C_R)=min(a_{i+1}, b_{j+1})$。算法只需要从$0$到$n$枚举$i$，当满足$max(a_{i},b_j)&lt;=min(a_{i+1}, b_{j+1})$条件时即可得到中位数。</p><p>采用二分法来枚举$i$。设$i_{min}=0$，$i_{max}=n$，令$i=(i_{min}+i_{max})/2$。</p><p>若$a_i&lt;=b_{j+1}$且$b_j&lt;=a_{i+1}$，算法结束，返回中位数为$(max(a_{i},b_j)+min(a_{i+1}, b_{j+1}))/2$；</p><p>若$a_i>=b_{j+1}$且$b_j&lt;=a_{i+1}$，说明需要减小$i$，于是令$i_{max}=i-1$，继续二分$i$进行枚举；</p><p>若$a_i&lt;=b_{j+1}$且$b_j>=a_{i+1}$，说明需要减小$j$，即增大$i$，于是令$i_{min}=i+1$，继续二分。</p><p>当$a_i>=b_{j+1}$时一定有$b_j&lt;=a_{i+1}$，若当$a_i>=b_{j+1}$时$b_j>=a_{i+1}$，则有$a_i>=b_{j+1}>=b_{j}>=a_{i+1}$，与$a_{i}&lt;=a_{i+1}$相矛盾。同理可证当$b_j>=a_{i+1}$时一定有$a_i&lt;=b_{j+1}$，因此上述三种情况可以涵盖完毕。</p><p>上述算法的伪代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>GetMedian</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>B</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>right</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>left</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=p>(</span><span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>j</span> <span class=o>=</span> <span class=n>n</span> <span class=o>-</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>(</span><span class=n>B</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=n>n</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>B</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>B</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=n>B</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>(</span><span class=nf>max</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>B</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=o>+</span> <span class=nf>min</span><span class=p>(</span><span class=n>B</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>],</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]))</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=n>B</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>left</span> <span class=o>=</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>B</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>right</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>其中将对数组A，B的下标访问操作视作对数据库的一次查询操作。</p><p>可以看到，每轮循环最多对数据库进行4次查询操作（假设重复查询存在缓存）则有时间复杂度$T(n)=T(n/2)+4$，由主定理可得$T(n)=O(logn)$。</p><h2 id=q2-平面最近点对>Q2 平面最近点对</h2><blockquote><p>给定任意10个点，p1，p2，…，p10，在二维欧几里得平面上，请写一个算法来求最近的一对点之间的距离。</p><p>（a）用蛮力算法来解决这个问题，分析你实现的蛮力算法的时间复杂度，并解释为什么算法的时间复杂度是$O(n^2)$，其中n是点数。</p><p>（b）提出一种改进算法来解决这个问题，时间复杂度优于蛮力算法。描述算法的思想并分析其时间复杂度</p></blockquote><h3 id=a>(a)</h3><p>暴力算法：对每两个点计算距离，若距离小于当前最小值，则更新最小值。</p><p>伪代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>minDist</span><span class=p>(</span><span class=n>P</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// P为点集，n为点的数量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>min_d</span> <span class=o>=</span> <span class=n>INF</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=err>计算</span><span class=n>P</span><span class=p>[</span><span class=n>i</span><span class=p>],</span><span class=n>P</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=err>两点的距离</span><span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>d</span> <span class=o>&lt;</span> <span class=n>min_d</span><span class=p>)</span> <span class=n>min_d</span> <span class=o>=</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>min_d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>对于计算两点间距离的操作，算法共进行$n(n-1)/2$次，因此算法的时间复杂度为$O(n^2)$。</p><h3 id=b>(b)</h3><p>算法描述：</p><p>设点集为$P$，首先将$P$中所有点按照以$x$坐标为第一关键字，$y$坐标为第二关键字从小到大进行排序。以中间点$p_m$的序号将点集分为两个集合$A$，$B$。对$A$和$B$分别调用本算法，得到点集$A$的结果$d_1$和点集$B$的结果$d_2$。</p><p>令$d=min(d_1, d_2)$。设集合$C=\lbrace p_i\mid p_i\in P, |p_i.x-p_m.x|&lt;=d\rbrace$，集合$C$中可能存在距离小于$d$且分别位于$A$和$B$的两点，因此求出集合$C$上的最短距离$d_c$，即可得到最短距离$d_{min}=min(d_c, d)。$</p><p>对于集合$C$的任意一点$p_i$，设集合$D_i={p_j\mid p_j\in C, p_i.y&lt;=p_j.y}$，求出$p_i$与$p_j$的距离并更新最短距离，即可求出点集$C$上的最短距离。</p><p>将集合$C$按照$y$坐标由小到大排序，则集合$D_i$中的点为$p_i$的相邻几个点。可以设置集合$T=\empty$，从大到小枚举$p_i$，并从大到小枚举$p_j\in T$，枚举$p_j$过程中保证$p_j.y &lt; p_i.y + d$，计算$p_i$与$p_j$间的距离并更新最小值，随后将$p_i$加入集合$T$，重复循环。可以看到在枚举过程中始终有$D_i \subseteq T$，且枚举$p_j$的集合恰好等于$D_i$。该算法保证没有多余的循环出现。</p><p>算法的复杂度取决于合并阶段求集合$C$上最短距离的时间复杂度，而该复杂度取决于集合$D_i$的规模大小，下面将通过证明$|D_i|$为常数从而证明这个操作是$O(n)$的。</p><img src=images/two.png alt=img style=zoom:50%><p>如图绿色阴影区域为集合$D_i$。对于右边每个小正方形，其对角线长度为$\frac{d}{\sqrt{2}}$，因此小正方形中最多含有一个点，因此集合$D_i$除位于最下方边界处的点$p_i$外最多存在7个点，由此，求集合$C$上最短距离的时间复杂度为$O(7n)=O(n)$。</p><p>此外，由于该算法要求集合$C$按照纵坐标排序，我们可以要求子问题将点集按照纵坐标排序，父问题只需要合并子问题的排序结果即可，合并排序的时间复杂度也为$O(n)$。故合并操作总的时间复杂度为$O(n)$。</p><p>当子问题规模足够小$(n &lt;= 3)$，即可暴力求解最短距离并排序点集。</p><p>算法的时间复杂度$T(n)=2T(\frac{n}{2})+O(n)$，根据主定理可得$T(n)=O(nlogn)$。</p><p>算法的伪代码如下：</p><p>定义全局变量最短距离d，每次计算两点距离便更新一次d。使用缓冲区数组T来保存集合C。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>d</span> <span class=o>=</span> <span class=n>INF</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>minDist</span><span class=p>(</span><span class=n>P</span><span class=p>,</span> <span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>right</span> <span class=o>-</span> <span class=n>left</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&lt;=</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>left</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=err>计算</span><span class=n>P</span><span class=p>[</span><span class=n>i</span><span class=p>],</span><span class=n>P</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=err>两点的距离并更新最小值</span><span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=err>以</span><span class=n>y为关键字排序点集P</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span> <span class=o>=</span> <span class=p>(</span><span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>minDist</span><span class=p>(</span><span class=n>P</span><span class=p>,</span> <span class=n>left</span><span class=p>,</span> <span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>minDist</span><span class=p>(</span><span class=n>P</span><span class=p>,</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=err>以</span><span class=n>y为关键字归并左右两个集合的排序结果</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=err>创建点集数组</span><span class=n>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>t_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>right</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=n>left</span><span class=p>;</span> <span class=o>--</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 反向建立集合C
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span><span class=p>(</span><span class=nf>abs</span><span class=p>(</span><span class=n>P</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>x</span> <span class=o>-</span> <span class=n>P</span><span class=p>[</span><span class=n>m</span><span class=p>].</span><span class=n>x</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>d</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=n>t_len</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>P</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>y</span> <span class=o>&lt;</span> <span class=n>P</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>y</span> <span class=o>+</span> <span class=n>d</span><span class=p>;</span> <span class=o>--</span><span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=err>计算</span><span class=n>P</span><span class=p>[</span><span class=n>i</span><span class=p>],</span><span class=n>P</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=err>两点的距离并更新最小值</span><span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>T</span><span class=p>[</span><span class=n>t_len</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>P</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>以</span><span class=n>x为第一关键字</span><span class=err>，</span><span class=n>y为第二关键字排序点集P</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>minDist</span><span class=p>(</span><span class=n>P</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=q3-快速次幂运算>Q3 快速次幂运算</h2><blockquote><p>给定一个整数n，其中100&lt;n&lt;10000，请设计一个高效算法计算$3^n$，时间复杂度不超过O（n）。</p><p>（a）实现一个朴素数据口径计算$3^n$，并分析该朴素数据口径的时间复杂度。</p><p>（b）提出一个改进算法计算$3^n$，时间复杂度不超过O（n）。描述算法的概念并分析其时间复杂度。</p></blockquote><h3 id=a-1>(a)</h3><p>将问题分割成n-1和1的子问题，即$f(n)=3*f(n-1)$，$f(1) = 3$。则递归或循环要进行n-1次，做n-1次乘法，时间复杂度为O(n)。</p><h3 id=b-1>(b)</h3><p>均匀地分割问题：</p><p>$$
f(n)= \begin{cases} f(\frac{n}{2})*f(\frac{n}{2})& \text{n为偶数} \\ f(\frac{n-1}{2})*f(\frac{n-1}{2})*3& \text{n为奇数}\end{cases}, f(1) = 3
$$</p><p>伪代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>f</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=k>return</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span> <span class=o>=</span> <span class=nf>f</span><span class=p>(</span><span class=n>n</span> <span class=o>/</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>t</span> <span class=o>*</span> <span class=n>t</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span> <span class=o>=</span> <span class=nf>f</span><span class=p>((</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>3</span> <span class=o>*</span> <span class=n>t</span> <span class=o>*</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>时间复杂度$T(n) = T(\frac{n}{2})+c$，由主定理可得$T(n) = O(logn)$。</p><h2 id=q4-反转二叉树>Q4 反转二叉树</h2><blockquote><p>给定一棵二叉树T，请给出一个O（n）算法来反转二叉树。例如下面，反转左二叉树，我们得到右二叉树。</p><img src=images/binary_tree.png alt=image-20231018203045181 style=zoom:50%></blockquote><p>算法描述：对于二叉树T，分别递归地调用本算法翻转左子树和右子树，随后交换左子树和右子树的索引。</p><p>伪代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>invert</span><span class=p>(</span><span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>t</span> <span class=o>==</span> <span class=n>null</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>invert</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>),</span> <span class=nf>invert</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>swap</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>时间复杂度分析：若二叉树为完全均匀的满二叉树，则时间复杂度$T(n)=2T(\frac{n}{2})+c$，由主定理可得$T(n)=O(n)$。对于一般情况，我们可以统计交换索引操作的次数。由伪代码可以看出，所有非空树结点都需要进行一次交换操作，由于存在n个树结点，因此操作数为n次，故时间复杂度为$O(n)$。</p><h2 id=q5-越狱状态数>Q5 越狱状态数</h2><blockquote><p>一个监狱有N个房间，每个囚犯一个，有M个宗教，每个囚犯都会遵循其中一个。如果相邻房间的囚犯是同一宗教的，可能会发生越狱。请给出一个O（n）算法，找出可以发生多少个状态的越狱。例如，有3个房间和2种宗教，那么将发生6种不同的状态的越狱。</p></blockquote><p>算法分析：</p><p>记规模为n的问题解为E(n)。从题目的形式可以看出，如果知道了E(n)，E(n+1)将很容易地由E(n)推出。设想在n个牢房的最右端加入1间牢房，若前n间牢房已经满足越狱状态，则新加入牢房的犯人不论是何种信仰均不影响整体的越狱状态，对应$E(n)*m$种情况；若前n间牢房未满足越狱状态，此时对应前n间牢房的状态总数减去前n间牢房的越狱状态数，即$m^n-E(n)$，此时若想使整体达到越狱状态，第n+1间牢房就需要安排与第n间牢房信仰相同的犯人，因此该种情况下n+1牢房的越狱状态数与$(m^n-E(n))$一一对应。故
$$
E(n+1)=E(n)*m+m^n-E(n)=(m-1)*E(n)+m^n
$$
第一项为线性递归式，时间复杂度为线性的，注意到计算式中存在$m^n$，为了使整体的时间复杂度为线性的，可设$G(n)=m^{n}$，总体的表达式如下：</p><p>$$E(n+1)=(m-1)*E(n)+G(n)，E(1) = 0$$</p><p>$$G(n+1)=n*G(n)， G(1)=m$$</p><p>算法的伪代码如下：(m为全局常数)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>Escape</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// return {E(n), G(n)}
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=k>return</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=n>m</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>e</span><span class=p>,</span> <span class=n>g</span> <span class=o>=</span> <span class=nf>Escape</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>g_next</span> <span class=o>=</span> <span class=n>n</span> <span class=o>*</span> <span class=n>g</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>e_next</span> <span class=o>=</span> <span class=p>(</span><span class=n>m</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>e</span> <span class=o>+</span> <span class=n>g</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=n>e_next</span><span class=p>,</span> <span class=n>g_next</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>每次递归共进行4次算术操作，共进行n-1次递归，故时间复杂度$T(n)=4(n-1)=O(n)$。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/algorithm/>Algorithm</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/posts/algo_heap/><div class=article-image><img src=/posts/algo_heap/images/image-feature.df1a62149da63cce32e4a7f8cdde649b_hu12955357344161368339.png width=250 height=150 loading=lazy alt="Featured image of post 算法笔记|二叉堆，二项堆和斐波那契堆（原理篇）" data-hash="md5-3xpiFJ2mPM4y5Kf4zd5kmw=="></div><div class=article-details><h2 class=article-title>算法笔记|二叉堆，二项堆和斐波那契堆（原理篇）</h2></div></a></article></div></div></aside><script src=//cdn.jsdelivr.net/npm/twikoo@1.6.21/dist/twikoo.all.min.js></script><div id=tcomment></div><style>.twikoo{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}:root[data-scheme=dark]{--twikoo-body-text-color-main:rgba(255, 255, 255, 0.9);--twikoo-body-text-color:rgba(255, 255, 255, 0.7)}.twikoo .el-input-group__prepend,.twikoo .tk-action-icon,.twikoo .tk-submit-action-icon,.twikoo .tk-time,.twikoo .tk-comments-no,.twikoo .tk-comments-count{color:var(--twikoo-body-text-color)}.twikoo .el-input__inner,.twikoo .el-textarea__inner,.twikoo .tk-preview-container,.twikoo .tk-content,.twikoo .tk-nick,.twikoo .tk-send{color:var(--twikoo-body-text-color-main)}.twikoo .el-button{color:var(--twikoo-body-text-color)!important}.twikoo .el-input__count{color:var(--twikoo-body-text-color)!important}.OwO .OwO-body{background-color:var(--body-background)!important;color:var(--body-text-color)!important}</style><script>twikoo.init({envId:"https://scintillating-dragon-68e1aa.netlify.app/.netlify/functions/twikoo",el:"#tcomment"})</script><footer class=site-footer><section class=copyright>&copy;
2021 -
2024 麦茶</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.21.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300&family=Noto+Serif+SC:wght@400&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><style>:root{--zh-font-family:"Noto Serif SC", "PingFang SC", "Hiragino Sans GB", "Droid Sans Fallback", "Microsoft YaHei";--article-font-family:Verdana, "Noto Serif SC", var(--base-font-family)}</style></body></html>