<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithm on 麦茶小站</title><link>https://chengyuan-artist.github.io/tags/algorithm/</link><description>Recent content in Algorithm on 麦茶小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>麦茶</copyright><lastBuildDate>Wed, 15 Nov 2023 20:43:01 +0800</lastBuildDate><atom:link href="https://chengyuan-artist.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>算法笔记|二叉堆，二项堆和斐波那契堆（原理篇）</title><link>https://chengyuan-artist.github.io/posts/algo_heap/</link><pubDate>Wed, 15 Nov 2023 20:43:01 +0800</pubDate><guid>https://chengyuan-artist.github.io/posts/algo_heap/</guid><description>&lt;img src="https://chengyuan-artist.github.io/posts/algo_heap/images/image-feature.png" alt="Featured image of post 算法笔记|二叉堆，二项堆和斐波那契堆（原理篇）" />&lt;h2 id="优先队列">优先队列&lt;/h2>
&lt;h3 id="动机">动机&lt;/h3>
&lt;p>某些情况下，我们需要频繁地&lt;strong>动态&lt;/strong>地取出一个集合S中的最小元素/最大元素。&lt;/p>
&lt;p>这里&lt;strong>动态&lt;/strong>指我们需要在集合S上执行插入/删除/更改键值操作。&lt;/p>
&lt;p>问题在于如何组织数据结构使这些操作更高效。&lt;/p>
&lt;h3 id="操作定义">操作定义&lt;/h3>
&lt;p>以最小优先队列为例：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>方法名&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>MakeHeap()&lt;/td>
&lt;td>建立一个堆H&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Insert(H, x)&lt;/td>
&lt;td>在堆H中插入元素x&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ExtractMin(H)&lt;/td>
&lt;td>提取堆H中的最小元素&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DecreaseKey(H, x, k)&lt;/td>
&lt;td>减小堆中元素x的键值为k&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Union(H1 , H2 )&lt;/td>
&lt;td>返回一个新堆包含H1和H2的所有元素，销毁输入堆&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="应用举例">应用举例&lt;/h3>
&lt;ul>
&lt;li>Dijkstra单源最短路算法：需要&lt;code>ExtractMin&lt;/code>&lt;/li>
&lt;li>Prim最小生成树算法：需要&lt;code>ExtractMin&lt;/code>与&lt;code>DecreaseKey&lt;/code>&lt;/li>
&lt;li>Why we need Union?&lt;/li>
&lt;/ul>
&lt;h2 id="数组链表实现">数组/链表实现&lt;/h2>
&lt;p>我们可以用数组或链表快速实现一个简单版本的优先队列。&lt;/p>
&lt;p>由于本篇偏向理论分析，因此更在意数据结构的&lt;strong>逻辑结构&lt;/strong>而非物理结构。对以下两种实现方式而言，可以认为数组的逻辑结构和链表相同（实际上二者复杂度分析也相同），因此都用链表代替。&lt;/p>
&lt;h3 id="无序链表实现">无序链表实现&lt;/h3>
&lt;img src="./images/image-20231115215858165.png" alt="image-20231115215858165" style="zoom: 50%;" />
&lt;p>每次都在首部插入新元素；提取最小值时，遍历链表找到最小值并更改链表指针将其从链表中删除。&lt;/p>
&lt;p>（数组版本）每次在尾部插入新元素；提取最小值时，遍历数组找到最小值并将其与尾部元素交换位置，减小长度计数。&lt;/p>
&lt;p>复杂度：&lt;/p>
&lt;ul>
&lt;li>插入操作：$O(1)$&lt;/li>
&lt;li>提取最小值：$O(n)$&lt;/li>
&lt;/ul>
&lt;h3 id="有序链表实现">有序链表实现&lt;/h3>
&lt;img src="./images/image-20231115220444807.png" alt="image-20231115220444807" style="zoom:50%;" />
&lt;p>插入新元素时，遍历链表至第一个大于其的元素位置处，在此之前插入；提取最小值直接返回首部，并将其删除（更改头指针）。&lt;/p>
&lt;p>（数组版本）倒序维护数组大小，插入新元素时，遍历链表至第一个小于其的元素位置处，在此之前插入，后续元素后移；提取最小值时直接返回尾部，并将其删除（减小长度计数）。&lt;/p>
&lt;p>复杂度：&lt;/p>
&lt;ul>
&lt;li>插入操作：$O(n)$&lt;/li>
&lt;li>提取最小值：$O(1)$&lt;/li>
&lt;/ul>
&lt;h3 id="问题">问题&lt;/h3>
&lt;p>是否存在使得插入和提取最小值时间复杂度更均衡/更优的数据结构？&lt;/p>
&lt;h2 id="二叉堆">二叉堆&lt;/h2>
&lt;p>观察有序链表实现，插入操作实际上每次都在进行插入排序以维持整个链表的有序，然而这属于工作过头了，我们只需要维护一个最小值。&lt;/p>
&lt;ul>
&lt;li>有序链表的每个指针指向的元素都大于等于自身，数据结构限制过于严格，因此需要&lt;strong>放松限制&lt;/strong>。&lt;/li>
&lt;li>但限制不能&lt;strong>过分放松&lt;/strong>，否则就会像无序链表那样，元素间没有任何限制，导致提取操作复杂度上升。&lt;/li>
&lt;/ul>
&lt;p>二叉堆：&lt;/p>
&lt;ul>
&lt;li>逻辑结构：一颗二叉树，且父结点小于子结点。所有结点除最后一层外按照完全二叉树排列。&lt;/li>
&lt;/ul>
&lt;img src="images/image-20231115224930406.png" alt="image-20231115224930406" style="zoom: 67%;" />
&lt;ul>
&lt;li>
&lt;p>物理结构：为了便于随机读取以及减少指针开销。结点以完全二叉树编号为下标放入数组中。&lt;/p>
&lt;img src="images/image-20231115225848350.png" alt="image-20231115225848350" style="zoom: 67%;" />
&lt;p>因此对结点$i$ ，左子结点下标为$2i$，右子结点下标为$2(i + 1)$，父结点下标为$ (i-1)/2$（向下取整）。下标越界时，表示结点不存在。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>操作：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>插入：将新元素置于二叉堆尾部，依次向上调整，使得最小堆性质（父结点小于子结点）保持。由于二叉堆高为$log_2n$（$n$为元素个数），因此时间复杂度为$O(logn)$。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>提取最小值：将堆顶元素与堆尾元素交换，减小堆数组长度计数，从根结点开始依次向下调整，使得最小堆性质保持。时间复杂度为$O(logn)$。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>DecreaseKey(x, k)&lt;/code>：将下标&lt;code>x&lt;/code>处元素值降低为&lt;code>k&lt;/code>。从该元素开始依次向上调整。时间复杂度为$O(logn)$。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>建堆：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>通过建空堆依次入堆。时间复杂度$O(nlogn)$。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过&amp;quot;遍历堆化&amp;quot;实现。将所有元素原封不动地入堆，随后调整堆结构。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>方法：按照完全二叉树编号从尾结点开始向根结点依次调用“向下调整”。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>时间复杂度：将堆补充为完全二叉树，不影响复杂度计算。设层高为$d = log_2n$。从上到下依次为第0&amp;hellip;d层。对第i层，操作总次数为$2^i*(d-i)$​。因此总操作数
$$
T(n)=2^0d+2^1(d-1)+2^2(d-2)&amp;hellip;+2^{d-1}
$$&lt;/p>
&lt;p>$$
2T(n)=2^1d+2^2(d-1)+&amp;hellip;+2^{d}
$$&lt;/p>
&lt;p>故
$$
T(n)=2^1+2^2+&amp;hellip;+2^d -d=2\frac{1-2^d}{1-2}-d=2^{d+1}-d-2=O(2^{d+1})=O(n)
$$&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>合并：将两个堆的数据组成一个堆，再遍历堆化。$O(n)$。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>至此，我们得到了插入，提取，改键均为$O(logn)$，且合并为$O(n)$的堆。实现简单且复杂度不错。&lt;/p>
&lt;h3 id="问题-1">问题&lt;/h3>
&lt;p>如果想进一步降低&lt;strong>合并&lt;/strong>的复杂度，该怎样调整数据结构？&lt;/p>
&lt;h2 id="二项式堆">二项式堆&lt;/h2>
&lt;p>观察二叉堆的逻辑结构，我们发现只允许&lt;strong>一棵树&lt;/strong>存在这一限制。因此在两个堆合并时，需要拆散两颗树合并为一颗。如果允许多棵树存在，逻辑结构不是一棵树而是&lt;strong>森林&lt;/strong>。合并时无需破坏原有堆的结构。&lt;/p>
&lt;ul>
&lt;li>放松限制：一棵树 -&amp;gt; 允许森林&lt;/li>
&lt;li>不要过分放松：&lt;strong>同类型&lt;/strong>的树只存在一颗。&lt;/li>
&lt;/ul>
&lt;p>综上，既然允许多棵树存在，插入操作就变成了&lt;strong>合并&lt;/strong>操作，即合并一颗只含根结点的树，直接将其插入森林中即可；由于同类型的树只能有一颗，我们需要合并&lt;strong>同类型&lt;/strong>的树，合并后的树也应该属于&lt;strong>某个类型&lt;/strong>。&lt;/p>
&lt;h3 id="二项树">二项树&lt;/h3>
&lt;p>定义：$B_k$为二项式树，定义$k$为$B_k$的度数。&lt;/p>
&lt;ul>
&lt;li>$B_0$只含有一个结点&lt;/li>
&lt;li>两个$B_k$可以合并为$B_{k+1}$&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>这里合并操作指将$B_k$作为另一$B_k$的根结点的儿子插入。&lt;/p>
&lt;/blockquote>
&lt;p>这样的定义使二项树有一些有趣的性质：&lt;/p>
&lt;ul>
&lt;li>$B_k$树层高为$k$&lt;/li>
&lt;li>$B_{k}$树的每个子结点分别为$B_0,B_1,&amp;hellip;,B_{k-1}$ （$B_k$树的第$i$个子结点的度为$i-1$）&lt;/li>
&lt;li>$B_k$树的每层结点个数正好是$k$的二项式系数（$(a+b)^k$）（命名来源）&lt;/li>
&lt;li>$|B_k|=2^k$&lt;/li>
&lt;/ul>
&lt;h3 id="二项堆">二项堆&lt;/h3>
&lt;p>定义：二项堆为二项树组成的森林&lt;/p>
&lt;ul>
&lt;li>其中每个度数的二项树只有一颗&lt;/li>
&lt;li>对于二项堆中的每颗二项树，满足最小堆性质&lt;/li>
&lt;/ul>
&lt;p>由此，当二项堆里有相同类型的二项树需要合并时，取根结点最小的树的根结点作为父结点，将另一棵树作为其儿子插入。&lt;/p>
&lt;p>二叉堆二项树根结点用双向链表连接，指针指向最小的根结点。&lt;/p>
&lt;p>二项堆也有一些有趣的性质：&lt;/p>
&lt;ul>
&lt;li>对于规模为$n$的二项堆，其二项树的组合是&lt;strong>确定&lt;/strong>的。二项堆含有$B_i$当且仅当$b_i=1$，其中$(b_kb_{k-1}&amp;hellip;b_0)_2=n$。&lt;/li>
&lt;li>二项堆最多含有$log_2n$（向下取整）颗二项树&lt;/li>
&lt;li>二项堆的层高不超过$log_2n$（向下取整）&lt;/li>
&lt;/ul>
&lt;p>操作：&lt;/p>
&lt;ul>
&lt;li>插入：合并一颗$B_0$树。最好情况下$O(1)$，最坏情况下$O(logn)$，均摊复杂度为$O(1)$。这是什么？别急&lt;/li>
&lt;li>提取最小值：将最小根结点取出，将该二项树拆为其所有子树，合并相同类型的二项树。$O(logn)$。&lt;/li>
&lt;li>合并：复杂度$O(logn)$，均摊复杂度$O(1)$。&lt;/li>
&lt;li>减小键值：在某颗二项树上向上调整。$O(logn)$。&lt;/li>
&lt;/ul>
&lt;h3 id="均摊分析">均摊分析&lt;/h3>
&lt;p>为什么要均摊分析？在分析插入/合并/提取最小值时，我们总考虑工作量的上限，即最坏情况，推出复杂度均为$O(logn)$。但是这三个操作复杂度在时间上具有继承性，如果做了一次工作量较大的操作，随后许多次操作都只需要很小的工作量。这种情况下可以引入&lt;strong>势能分析&lt;/strong>。&lt;/p>
&lt;h4 id="插入">插入&lt;/h4>
&lt;p>伪代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Insert(x) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Creat a B0 tree for x;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Change the pointer to the min root;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (there are two Bk tree for some k) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Link them into one Bk+1 tree;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Change the pointer to the min root;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>一次插入操作需要消耗$1+w$时间，$w=\#while$ 是&lt;code>while&lt;/code>语句执行的数量，$\#$表示&lt;code>number of&lt;/code>。&lt;/p>
&lt;p>引入势函数$\Phi=\#tree$，即二叉堆中树的数量。当进行一次插入操作后，势函数可以分为上升的部分和下降的部分。&lt;/p>
&lt;ul>
&lt;li>上升：$1$&lt;/li>
&lt;li>下降：$w$，即树减少的数量&lt;/li>
&lt;/ul>
&lt;p>因此一次插入操作需要$1+decrease\ in\ \Phi$。而由于$\Phi&amp;gt;=0$，故$all\ decrease\ in\ \Phi &amp;lt;= all\ increase\ in\ \Phi$。这为我们统计一系列操作提供了方便。&lt;/p>
&lt;p>可以看到，当分析合并时，伪代码与插入只有第二行的区别，一次合并操作需要的时间也是$1+decrease\ in\ \Phi$。&lt;/p>
&lt;h4 id="提取最小值">提取最小值&lt;/h4>
&lt;p>伪代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ExtractMin(H) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Remove the min node and insert its children to the root list;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Change the pointer to the min node;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (there are two Bk tree for some k) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Link them into one Bk+1 tree;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Change the pointer to the min root;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>一次操作需要消耗$d+w$，$w=\#while$，$d$为去除根结点的树的度（也是其子树数量）。&lt;/p>
&lt;p>我们用同样的势函数$\Phi=\#tree$。进行一次操作，势函数既有上升的部分也有下降的部分。&lt;/p>
&lt;ul>
&lt;li>上升：$d$&lt;/li>
&lt;li>下降：$w$&lt;/li>
&lt;/ul>
&lt;p>因此一次操作需要$d+decrease\ in\ \Phi$。其中$d&amp;lt;=log_2n$。&lt;/p>
&lt;h4 id="分析">分析&lt;/h4>
&lt;p>若对一个二叉堆做了$a$次插入操作和$b$次提取最小值操作，总消耗的时间&lt;/p>
&lt;p>$$
\begin{align*}
T(a,b)&amp;amp;= a(1+decrease\ in\ \Phi)+b(d+decrease\ in\ \Phi) \\\
&amp;amp;\le a(1+increase\ in\ \Phi)+b(d+increase\ in\ \Phi) \\\
&amp;amp;=a+bd+all\ increase\ in\ \Phi \\\
&amp;amp;=a+bd+a+bd=2a+2bd \\\
&amp;amp;\le 2a+2blogn
\end{align*}
$$
由于$n$与$m$无关，因此插入操作的均摊复杂度为$O(\frac{T(a)}{a})=O(1)$，提取最小值的操作的均摊复杂度为$O(\frac{T(b)}{b})=O(logn)$。合并操作均摊复杂度与插入操作相同，为$O(1)$。&lt;/p>
&lt;h3 id="问题-2">问题&lt;/h3>
&lt;p>对比二叉堆，我们成功地将合并操作的复杂度降低为$O(1)$（均摊）。如果进一步考虑，如何降低&lt;strong>减小键值&lt;/strong>的复杂度呢？&lt;/p>
&lt;h2 id="斐波那契堆">斐波那契堆&lt;/h2>
&lt;p>对于减小键值操作，无论是二叉堆还是二项堆，都避免不了对堆进行调整的操作。为了降低复杂度，能否进行操作后，不进行或推迟调整操作？&lt;/p>
&lt;p>斐波那契堆在二项堆的基础上：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>放松限制&lt;/strong>，允许同类型的二项树共存；同时在减小键值操作后，并不调整堆而是直接将该结点及其子树摘下放入根结点列表中，同时给该结点的父结点打上标记，已表明该父节点“失去”过一个结点。（1）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>注意到该限制不是&lt;strong>完全放松&lt;/strong>的，对每颗二项树而言，非根结点最多失去一个结点。（2）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>“摘下”操作相当于取消了原来的堆调整过程，将其推迟到堆做合并时。减小键值对应着摘下结点。&lt;/p>
&lt;p>当已被标记的结点的子结点被摘下后，该结点应取消标记并也被摘下，递归地向父结点进行直至没有标记。&lt;/p>
&lt;p>根结点不允许失去结点 -&amp;gt; 便于统计树的度数 。&lt;/p>
&lt;/blockquote>
&lt;p>注意到由于条件（1）的存在，插入和合并都只需向根结点列表中添加新的树即可。但堆总要做出调整，何时？&lt;/p>
&lt;p>答案是不得不调整时，即&lt;strong>提取最小值&lt;/strong>后，此时无论如何都要进行合并操作了，否则根结点列表数量将膨胀。&lt;/p>
&lt;p>合并操作是合并&lt;strong>相同度数&lt;/strong>的树。树的度数等于根结点的子结点数目。&lt;/p>
&lt;p>操作：&lt;/p>
&lt;ul>
&lt;li>插入：合并一颗$B_0$树。复杂度$O(1)$。&lt;/li>
&lt;li>提取最小值：将最小根结点取出，将拆为其所有子树并插入根结点列表。最坏&amp;amp;均摊$O(logn)$。为什么？&lt;/li>
&lt;li>合并：复杂度$O(1)$。&lt;/li>
&lt;li>减小键值：均摊复杂度$O(1)$。&lt;/li>
&lt;/ul>
&lt;h3 id="均摊分析-1">均摊分析&lt;/h3>
&lt;h4 id="提取最小值-1">提取最小值&lt;/h4>
&lt;p>伪代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ExtractMin() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Remove the min node and insert its children to the root list;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Change the pointer to the min node;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (there are two roots u and v of the same degree) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Consolidate the two trees together;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Change the pointer to the min root;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>与二叉堆的操作相同，但这里我们使用新的势函数$\Phi=\#tree+2\#mark$，$\#mark$为被标记的非根结点数量。 why?&lt;/p>
&lt;p>一次提取最小值操作带来的势函数变化为：&lt;/p>
&lt;ul>
&lt;li>上升（静态）：$d$（移除结点的度）&lt;/li>
&lt;li>下降（动态）：$w$&lt;/li>
&lt;/ul>
&lt;p>一次操作需要$d+decrease\ in\ \Phi$，$d$为根结点的度。&lt;/p>
&lt;blockquote>
&lt;p>注意到由于树会被摘下结点，因此$d$有可能大于$log_2n$。&lt;/p>
&lt;p>想象单颗二项树的情景，有$d=log_2n$，由于$n$减小，故$d&amp;gt;log_2n$。扩展到堆也可能成立。&lt;/p>
&lt;p>因此均摊操作复杂度取决于$d$的上界，后续会证明$d$的上界。思路：找到二项树对应的结点数最小的树，即斐波那契树的结点数目。&lt;/p>
&lt;/blockquote>
&lt;h4 id="减小键值">减小键值&lt;/h4>
&lt;p>再回想一下减小键值的操作：&lt;/p>
&lt;blockquote>
&lt;p>减小键值对应着摘下结点（若堆序被破坏）。&lt;/p>
&lt;p>当已被标记的结点的子结点被摘下后，该结点应取消标记并也被摘下，递归地向父结点进行直至没有标记。&lt;/p>
&lt;p>根结点不能失去结点：对父结点为根结点的操作特殊处理。&lt;/p>
&lt;/blockquote>
&lt;p>伪代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">DecreaseKey(x, k) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> key(x) = k;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (heap order is violated) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> p = x-&amp;gt;parent;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (p is root node) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Swap key between p and x;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Cut the subtree rooted at x, and insert it into the root list;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Change the pointer to the min root node;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (p is marked) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Cut the subtree rooted at p, and insert it into the root list;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Change the pointer to the min root node;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Unmark p;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> p = p-&amp;gt;parent;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Mark p;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>为了复杂度计算方便，暂时先不考虑&lt;code>x&lt;/code>的父结点为根结点的情况。由伪代码可以得到，一次操作消耗的时间为$1+w,w=\#while$。&lt;/p>
&lt;p>考察势函数$\Phi=\#tree+2\#mark$，一次减小键值操作带来的势函数变化为：&lt;/p>
&lt;ul>
&lt;li>上升（静态）：$1+2=3$&lt;/li>
&lt;li>下降（动态）：$（-1+2）w=w$&lt;/li>
&lt;/ul>
&lt;p>故一次操作消耗的时间为$1+decrease\ in\ \Phi$。&lt;/p>
&lt;p>当&lt;code>x&lt;/code>的父结点为根结点时也符合上式。&lt;/p>
&lt;h4 id="插入-1">插入&lt;/h4>
&lt;p>$\Phi$上升$1$，下降$0$。&lt;/p>
&lt;p>一次操作消耗的时间为$1$。&lt;/p>
&lt;h4 id="分析-1">分析&lt;/h4>
&lt;p>考虑一段操作序列：$r$次插入，$s$次提取最小值，$t$次减小键值。&lt;/p>
&lt;p>总的运行时间最大为：$r+sd_{max}+t+total\ decrease\ in\ \Phi$。&lt;/p>
&lt;p>注意到：$(total\ decrease\ in\ \Phi) \le (total\ increase\ in\ \Phi) = r+sd_{max}+3t$。&lt;/p>
&lt;p>因此总的运行时间最大为：$2r+2sd_{max}+4t$。&lt;/p>
&lt;p>因此插入的均摊复杂度为$O(1)$，减小键值的均摊复杂度为$O(1)$，提取最小值的均摊复杂度为$O(d_{max})$。&lt;/p>
&lt;h4 id="d_max限界分析">$d_{max}$限界分析&lt;/h4>
&lt;p>$d_{max}$为$d$的上界，限界即确定$d_{max}$与堆结点数目$n$的关系。&lt;/p>
&lt;p>考虑一颗$B_k$树，则其度$d=log_2n$，若堆中有多颗$B$树，相当于$n$增加，则其中一颗树的度$d&amp;lt;log_2n$。因此为了确定$d$的上界，堆中树越少越好，即只有一颗。&lt;/p>
&lt;p>考虑一颗$B_k$树，其度$d=log_2n$，若从其上摘下结点（减小键值操作），对单颗树来说，相当于$n$减小，则$d&amp;gt;log_2n$，当$n$最小时，此时取得最大的$d$。也可以考虑为$n$不变时，这种构成堆的方式（即单颗树且丢失最多的结点）可使$d$最大，即取到$d_{max}$。&lt;/p>
&lt;p>于是我们开始寻找各个度对应的最少结点树，不妨记其为$F_k$，$k$为度数：&lt;/p>
&lt;img src="images/image-20231122124352469.png" alt="image-20231122124352469" style="zoom: 50%;" />
&lt;img src="images/image-20231122124411709.png" alt="image-20231122124411709" style="zoom:50%;" />
&lt;img src="images/image-20231122124424160.png" alt="image-20231122124424160" style="zoom:50%;" />
&lt;img src="images/image-20231122124451912.png" alt="image-20231122124451912" style="zoom:50%;" />
&lt;img src="images/image-20231122124632445.png" alt="image-20231122124632445" style="zoom:50%;" />
&lt;p>回想二项树$B_{k+1}$由两颗$B_k$树构成：&lt;/p>
&lt;img src="images/image-20231122124742938.png" alt="image-20231122124742938" style="zoom:50%;" />
&lt;p>$F_{k+1}$树由$F_{k}$和$F_{k-1}$构成：&lt;/p>
&lt;img src="images/image-20231122125017065.png" alt="image-20231122125017065" style="zoom:50%;" />
&lt;p>尽管$|F_k|&amp;lt;|B_k|$，但不会小太多。$|F_k|\ge1.618^k$。&lt;/p>
&lt;p>对于斐波那契数列：
$$
f_k=f_{k-1}+f_{k-2},f_0=0,f_1=1
$$
注意到$|F_k|=f_{k+2}$，因为$|F_0|=f_2=1, |F_1|=f_3=2，|F_{k}|=|F_{k-1}|+|F_{k-2}|$。&lt;/p>
&lt;p>由斐波那契通项性质$f_{k+2} \ge \phi^k, \phi=\frac{1+\sqrt{5}}{2}=1.618&amp;hellip;$。&lt;/p>
&lt;p>考虑一个斐波那契堆含有$n$个结点，$T$为其中一颗树，其根结点度为$d$。&lt;/p>
&lt;p>则$n\ge|T|\ge|F_d|=f_{d+2}\ge\phi^d$。&lt;/p>
&lt;p>因此$d\le log_{\phi}n$。故$O(d_{max})=O(log_{\phi}n)=O(logn)$。&lt;/p>
&lt;p>因此提取最小值的均摊复杂度为$O(logn)$。&lt;/p></description></item><item><title>分治题解</title><link>https://chengyuan-artist.github.io/posts/divede_and_conquer_solution/</link><pubDate>Tue, 17 Oct 2023 11:21:52 +0800</pubDate><guid>https://chengyuan-artist.github.io/posts/divede_and_conquer_solution/</guid><description>&lt;img src="https://chengyuan-artist.github.io/posts/divede_and_conquer_solution/images/maxresdefault.jpg" alt="Featured image of post 分治题解" />&lt;p>朴东波算法课分治一节的算法作业及题解。&lt;/p>
&lt;h2 id="q1-两个升序数组的中位数">Q1 两个升序数组的中位数&lt;/h2>
&lt;blockquote>
&lt;p>你有兴趣分析来自两个独立数据库的一些难以获取的数据。每个数据库包含n个数值，因此总共有2n个值，你可以假设没有两个值是相同的。你想确定这组2n个值的中位数，我们将在这里将其定义为第n个最小值。但是，你可以访问这些值的唯一方法是通过对数据库的查询。在单个查询中，你可以为两个数据库之一指定一个值k，所选数据库将返回它包含的第k个最小值。由于查询很昂贵，因此你希望使用尽可能少的查询来计算中位数。给出一个最多使用O（logn）查询找到中位数的算法。&lt;/p>
&lt;/blockquote>
&lt;p>算法描述：记两个数据库中的数据分别构成集合$A$和$B$。&lt;/p>
&lt;p>取$A$中第$i$小的元素$a_i$，将$A$分成$A_L$ 和$A_R$两部分，其中&lt;/p>
&lt;p>$A_L= \lbrace a\mid a\in A, a&amp;lt;=a_i \rbrace$ ，$A_R= \lbrace a\mid a\in A, a&amp;gt;a_i \rbrace$。&lt;/p>
&lt;p>特别地，当$i=0$时，设$A_L=\emptyset$，$A_R=A$。&lt;/p>
&lt;p>同样，取$B$中第$j$小的元素$b_j$，将$B$分成$B_L$ 和$B_R$两部分，其中&lt;/p>
&lt;p>$B_L= \lbrace b\mid b\in B, b&amp;lt;=b_j \rbrace$，$B_R= \lbrace b \mid b\in B, b&amp;gt;b_j \rbrace$。&lt;/p>
&lt;p>特别地，当$j=0$时，设$B_L=\emptyset$，$B_R=B$。&lt;/p>
&lt;p>记$C_L=A_L\cup B_L$，$C_R=A_R\cup B_R$。&lt;/p>
&lt;p>当$|C_L|=|C_R|=n$ 且 $max(C_L) &amp;lt;= min(C_R)$时，题目所求的中位数即为$(max(C_L)+min(C_R))/2$。&lt;/p>
&lt;p>由$|C_L|=|C_R|=n$ 可得$i+j=n$，而$max(C_L)=max(a_{i},b_j)$，$min(C_R)=min(a_{i+1}, b_{j+1})$。算法只需要从$0$到$n$枚举$i$，当满足$max(a_{i},b_j)&amp;lt;=min(a_{i+1}, b_{j+1})$条件时即可得到中位数。&lt;/p>
&lt;p>采用二分法来枚举$i$。设$i_{min}=0$，$i_{max}=n$，令$i=(i_{min}+i_{max})/2$。&lt;/p>
&lt;p>若$a_i&amp;lt;=b_{j+1}$且$b_j&amp;lt;=a_{i+1}$，算法结束，返回中位数为$(max(a_{i},b_j)+min(a_{i+1}, b_{j+1}))/2$；&lt;/p>
&lt;p>若$a_i&amp;gt;=b_{j+1}$且$b_j&amp;lt;=a_{i+1}$，说明需要减小$i$，于是令$i_{max}=i-1$，继续二分$i$进行枚举；&lt;/p>
&lt;p>若$a_i&amp;lt;=b_{j+1}$且$b_j&amp;gt;=a_{i+1}$，说明需要减小$j$，即增大$i$，于是令$i_{min}=i+1$，继续二分。&lt;/p>
&lt;p>当$a_i&amp;gt;=b_{j+1}$时一定有$b_j&amp;lt;=a_{i+1}$，若当$a_i&amp;gt;=b_{j+1}$时$b_j&amp;gt;=a_{i+1}$，则有$a_i&amp;gt;=b_{j+1}&amp;gt;=b_{j}&amp;gt;=a_{i+1}$，与$a_{i}&amp;lt;=a_{i+1}$相矛盾。同理可证当$b_j&amp;gt;=a_{i+1}$时一定有$a_i&amp;lt;=b_{j+1}$，因此上述三种情况可以涵盖完毕。&lt;/p>
&lt;p>上述算法的伪代码如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">GetMedian&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nf">min&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]))&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">continue&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中将对数组A，B的下标访问操作视作对数据库的一次查询操作。&lt;/p>
&lt;p>可以看到，每轮循环最多对数据库进行4次查询操作（假设重复查询存在缓存）则有时间复杂度$T(n)=T(n/2)+4$，由主定理可得$T(n)=O(logn)$。&lt;/p>
&lt;h2 id="q2-平面最近点对">Q2 平面最近点对&lt;/h2>
&lt;blockquote>
&lt;p>给定任意10个点，p1，p2，…，p10，在二维欧几里得平面上，请写一个算法来求最近的一对点之间的距离。&lt;/p>
&lt;p>（a）用蛮力算法来解决这个问题，分析你实现的蛮力算法的时间复杂度，并解释为什么算法的时间复杂度是$O(n^2)$，其中n是点数。&lt;/p>
&lt;p>（b）提出一种改进算法来解决这个问题，时间复杂度优于蛮力算法。描述算法的思想并分析其时间复杂度&lt;/p>
&lt;/blockquote>
&lt;h3 id="a">(a)&lt;/h3>
&lt;p>暴力算法：对每两个点计算距离，若距离小于当前最小值，则更新最小值。&lt;/p>
&lt;p>伪代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">minDist&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// P为点集，n为点的数量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">min_d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">INF&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">计算&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">两点的距离&lt;/span>&lt;span class="n">d&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">d&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">min_d&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">min_d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">d&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">min_d&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对于计算两点间距离的操作，算法共进行$n(n-1)/2$次，因此算法的时间复杂度为$O(n^2)$。&lt;/p>
&lt;h3 id="b">(b)&lt;/h3>
&lt;p>算法描述：&lt;/p>
&lt;p>设点集为$P$，首先将$P$中所有点按照以$x$坐标为第一关键字，$y$坐标为第二关键字从小到大进行排序。以中间点$p_m$的序号将点集分为两个集合$A$，$B$。对$A$和$B$分别调用本算法，得到点集$A$的结果$d_1$和点集$B$的结果$d_2$。&lt;/p>
&lt;p>令$d=min(d_1, d_2)$。设集合$C=\lbrace p_i\mid p_i\in P, |p_i.x-p_m.x|&amp;lt;=d\rbrace$，集合$C$中可能存在距离小于$d$且分别位于$A$和$B$的两点，因此求出集合$C$上的最短距离$d_c$，即可得到最短距离$d_{min}=min(d_c, d)。$&lt;/p>
&lt;p>对于集合$C$的任意一点$p_i$，设集合$D_i={p_j\mid p_j\in C, p_i.y&amp;lt;=p_j.y}$，求出$p_i$与$p_j$的距离并更新最短距离，即可求出点集$C$上的最短距离。&lt;/p>
&lt;p>将集合$C$按照$y$坐标由小到大排序，则集合$D_i$中的点为$p_i$的相邻几个点。可以设置集合$T=\empty$，从大到小枚举$p_i$，并从大到小枚举$p_j\in T$，枚举$p_j$过程中保证$p_j.y &amp;lt; p_i.y + d$，计算$p_i$与$p_j$间的距离并更新最小值，随后将$p_i$加入集合$T$，重复循环。可以看到在枚举过程中始终有$D_i \subseteq T$，且枚举$p_j$的集合恰好等于$D_i$。该算法保证没有多余的循环出现。&lt;/p>
&lt;p>算法的复杂度取决于合并阶段求集合$C$上最短距离的时间复杂度，而该复杂度取决于集合$D_i$的规模大小，下面将通过证明$|D_i|$为常数从而证明这个操作是$O(n)$的。&lt;/p>
&lt;img src="images/two.png" alt="img" style="zoom:50%;" />
&lt;p>如图绿色阴影区域为集合$D_i$。对于右边每个小正方形，其对角线长度为$\frac{d}{\sqrt{2}}$，因此小正方形中最多含有一个点，因此集合$D_i$除位于最下方边界处的点$p_i$外最多存在7个点，由此，求集合$C$上最短距离的时间复杂度为$O(7n)=O(n)$。&lt;/p>
&lt;p>此外，由于该算法要求集合$C$按照纵坐标排序，我们可以要求子问题将点集按照纵坐标排序，父问题只需要合并子问题的排序结果即可，合并排序的时间复杂度也为$O(n)$。故合并操作总的时间复杂度为$O(n)$。&lt;/p>
&lt;p>当子问题规模足够小$(n &amp;lt;= 3)$，即可暴力求解最短距离并排序点集。&lt;/p>
&lt;p>算法的时间复杂度$T(n)=2T(\frac{n}{2})+O(n)$，根据主定理可得$T(n)=O(nlogn)$。&lt;/p>
&lt;p>算法的伪代码如下：&lt;/p>
&lt;p>定义全局变量最短距离d，每次计算两点距离便更新一次d。使用缓冲区数组T来保存集合C。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">INF&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">minDist&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">right&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">计算&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">两点的距离并更新最小值&lt;/span>&lt;span class="n">d&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">以&lt;/span>&lt;span class="n">y为关键字排序点集P&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">minDist&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">minDist&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">m&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">以&lt;/span>&lt;span class="n">y为关键字归并左右两个集合的排序结果&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">创建点集数组&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t_len&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 反向建立集合C
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">m&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">d&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t_len&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">d&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">计算&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">两点的距离并更新最小值&lt;/span>&lt;span class="n">d&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">T&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">t_len&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">以&lt;/span>&lt;span class="n">x为第一关键字&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">y为第二关键字排序点集P&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">minDist&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="q3-快速次幂运算">Q3 快速次幂运算&lt;/h2>
&lt;blockquote>
&lt;p>给定一个整数n，其中100&amp;lt;n&amp;lt;10000，请设计一个高效算法计算$3^n$，时间复杂度不超过O（n）。&lt;/p>
&lt;p>（a）实现一个朴素数据口径计算$3^n$，并分析该朴素数据口径的时间复杂度。&lt;/p>
&lt;p>（b）提出一个改进算法计算$3^n$，时间复杂度不超过O（n）。描述算法的概念并分析其时间复杂度。&lt;/p>
&lt;/blockquote>
&lt;h3 id="a-1">(a)&lt;/h3>
&lt;p>将问题分割成n-1和1的子问题，即$f(n)=3*f(n-1)$，$f(1) = 3$。则递归或循环要进行n-1次，做n-1次乘法，时间复杂度为O(n)。&lt;/p>
&lt;h3 id="b-1">(b)&lt;/h3>
&lt;p>均匀地分割问题：&lt;/p>
&lt;p>$$
f(n)= \begin{cases} f(\frac{n}{2})*f(\frac{n}{2})&amp;amp; \text{n为偶数} \\ f(\frac{n-1}{2})*f(\frac{n-1}{2})*3&amp;amp; \text{n为奇数}\end{cases}, f(1) = 3
$$&lt;/p>
&lt;p>伪代码如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>时间复杂度$T(n) = T(\frac{n}{2})+c$，由主定理可得$T(n) = O(logn)$。&lt;/p>
&lt;h2 id="q4-反转二叉树">Q4 反转二叉树&lt;/h2>
&lt;blockquote>
&lt;p>给定一棵二叉树T，请给出一个O（n）算法来反转二叉树。例如下面，反转左二叉树，我们得到右二叉树。&lt;/p>
&lt;img src="images/binary_tree.png" alt="image-20231018203045181" style="zoom: 50%;" />
&lt;/blockquote>
&lt;p>算法描述：对于二叉树T，分别递归地调用本算法翻转左子树和右子树，随后交换左子树和右子树的索引。&lt;/p>
&lt;p>伪代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">invert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">null&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">invert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nf">invert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>时间复杂度分析：若二叉树为完全均匀的满二叉树，则时间复杂度$T(n)=2T(\frac{n}{2})+c$，由主定理可得$T(n)=O(n)$。对于一般情况，我们可以统计交换索引操作的次数。由伪代码可以看出，所有非空树结点都需要进行一次交换操作，由于存在n个树结点，因此操作数为n次，故时间复杂度为$O(n)$。&lt;/p>
&lt;h2 id="q5-越狱状态数">Q5 越狱状态数&lt;/h2>
&lt;blockquote>
&lt;p>一个监狱有N个房间，每个囚犯一个，有M个宗教，每个囚犯都会遵循其中一个。如果相邻房间的囚犯是同一宗教的，可能会发生越狱。请给出一个O（n）算法，找出可以发生多少个状态的越狱。例如，有3个房间和2种宗教，那么将发生6种不同的状态的越狱。&lt;/p>
&lt;/blockquote>
&lt;p>算法分析：&lt;/p>
&lt;p>记规模为n的问题解为E(n)。从题目的形式可以看出，如果知道了E(n)，E(n+1)将很容易地由E(n)推出。设想在n个牢房的最右端加入1间牢房，若前n间牢房已经满足越狱状态，则新加入牢房的犯人不论是何种信仰均不影响整体的越狱状态，对应$E(n)*m$种情况；若前n间牢房未满足越狱状态，此时对应前n间牢房的状态总数减去前n间牢房的越狱状态数，即$m^n-E(n)$，此时若想使整体达到越狱状态，第n+1间牢房就需要安排与第n间牢房信仰相同的犯人，因此该种情况下n+1牢房的越狱状态数与$(m^n-E(n))$一一对应。故
$$
E(n+1)=E(n)*m+m^n-E(n)=(m-1)*E(n)+m^n
$$
第一项为线性递归式，时间复杂度为线性的，注意到计算式中存在$m^n$，为了使整体的时间复杂度为线性的，可设$G(n)=m^{n}$，总体的表达式如下：&lt;/p>
&lt;p>$$E(n+1)=(m-1)*E(n)+G(n)，E(1) = 0$$&lt;/p>
&lt;p>$$G(n+1)=n*G(n)， G(1)=m$$&lt;/p>
&lt;p>算法的伪代码如下：(m为全局常数)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">Escape&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// return {E(n), G(n)}
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">e&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">g&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">Escape&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">g_next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">g&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">e_next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">m&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">e&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">g&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">e_next&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">g_next&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>每次递归共进行4次算术操作，共进行n-1次递归，故时间复杂度$T(n)=4(n-1)=O(n)$。&lt;/p></description></item></channel></rss>